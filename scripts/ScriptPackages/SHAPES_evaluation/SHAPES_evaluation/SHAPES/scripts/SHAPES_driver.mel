// --------------------------------------------------------------------------------------------------
//
// SHAPES
//
// blend shape editing tool for Maya
//
// required plugins:
//   SHAPESTools
//
// Ingo Clemens
// www.braverabbit.com
//
// copyright brave rabbit, Ingo Clemens 2014-2018
//
// --------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------
//
// THE SOFTWARE PRODUCT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
// IMPLIED, INCLUDING, BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NON-INFRINGEMENT OF THIRD-PARTY RIGHTS. THE ENTIRE RISK AS TO THE QUALITY AND
// PERFORMANCE OF THE SOFTWARE PRODUCT IS WITH YOU.
// NEITHER BRAVE RABBIT NOR ITS SUPPLIERS WARRANT THAT THE FUNCTIONS CONTAINED IN THE SOFTWARE
// PRODUCT WILL MEET YOUR REQUIREMENTS OR THAT THE OPERATION OF THE SOFTWARE PRODUCT WILL BE
// UNINTERRUPTED OR ERROR-FREE. BRAVE RABBIT IS NOT OBLIGATED TO PROVIDE ANY UPDATES TO THE
// SOFTWARE.
// IN NO EVENT SHALL THE AUTHOR OF THIS SOFTWARE PRODUCT BE LIABLE FOR ANY SPECIAL, CONSEQUENTIAL,
// INCIDENTAL, DIRECT OR INDIRECT DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
// LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, FOR PERSONAL INJURY, LOSS OF BUSINESS
// INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THIS
// PRODUCT, EVEN IF THE AUTHOR OF THIS SOFTWARE PRODUCT IS AWARE OF THE POSSIBILITY OF SUCH
// DAMAGES AND KNOWN DEFECTS, ANY CLAIM BY A THIRD PARTY AND EVEN IF THE REMEDY FAILS OF ITS
// ESSENTIAL PURPOSE.
//
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
// button actions for shape drivers and combos
// --------------------------------------------------------------------------------------------------

global proc shapesDriver_initButtonAction( int $btn, string $shape, int $state )
{
	//
	// call the action for the button and request confirmation if needed
	// {"buttons": [{"node": "blendShape1_smile", "ann": "", "type": "animation"}, {"node": "", "ann": "", "type": ""}], "target": "smile"}
	// incoming arguments:
	// button index, targetName, state
	//
	global int $gShapes_comboProcess;
	global int $gShapes_sequenceProcess;
	global string $gShapes_rampPlug;
	global string $gShapes_orderedTargetList[];
	
	$gShapes_rampPlug = "";
	
	// show the options for editing the rampWeights node
	if ($btn == 2)
	{
		// if the selected item is not a helper attribute
		// select the target shape and show the weights ui
		if (!shapesData_isHelper($shape))
		{
			int $index = shapesData_getShapeIndex($shape);
			shapesWeights_editWeightsController $shape $index (shapesData_getWeightsControllerConnection($index));
		}
		return;
	}
	
	if (!`optionVar -q SHAPESShowUIDriver`)
		return;
	
	// bail if the process of creating a combo is currently active
	if ($gShapes_comboProcess || $gShapes_sequenceProcess)
	{
		string $infoMsg = "creating a combo";
		if ($gShapes_sequenceProcess)
			$infoMsg = "editing the driver sequence";
		br_displayMessage -warning ("The target buttons are inactive while " + $infoMsg + " is in progress. Select the target shape from the list");
		return;
	}
	
	// get the id of the button
	int $idList = shapesData_getListIndex($shape);
	
	// just for safety reasons if the list gets corrupted
	if ($idList == -1)
		br_displayMessage -error "Unable to find selected target";
	
	// define the select action if the driver buttons are not sdk or shape driver
	// or if the combo button has a combo attached
	string $node;
	string $type;
	string $ann;
	if ($btn == 0)
	{
		string $input[] = shapesMain_getTargetInput(shapesMain_getQueryPlug($shape));
		$node = $input[0];
		$type = $input[1];
		$ann = shapesList_getButtonAnnotation({$input[0]}, {$input[1]}, 1);
		if (shapesData_getNonShapeType($shape) != "group" && $ann == "Select")
			$ann = "";
	}
	else
	{
		string $resultNodes[];
		string $resultTypes[];
		shapesMain_getTargetOutput(shapesMain_getQueryPlug($shape), $resultNodes, $resultTypes);
		$node = $resultNodes[0];
		$type = $resultTypes[1];
		$ann = shapesList_getButtonAnnotation($resultNodes, $resultTypes, 0);
		if (shapesData_getNonShapeType($shape) != "group" && $ann == "Select")
			$ann = "";
	}
	
	if (($btn == 0 && $type != "sdk" && $type != "sdks" && $type != "wd" && $type != "rbf" && $type != "combo" && $type != "pi" && $type != "") || ($ann == "Select"))
	{
		shapesUI_selectNode("button", {$node}, $shape, "");
		return;
	}
	
	string $msg;
	int $create;
	int $driver;
	
	// create mode
	// if the shape driver button has no input or the combo button no output
	// or if the target is not controlled by a combo
	if (($btn == 0 && $type == "") || ($btn == 1 && ($type == "" || $type == "combo")))
	{
		$msg = "Create ";
		$create = 1;
	}
	else
		$msg = "Delete ";
	
	string $buttonList[] = {"OK", "Cancel"};
	
	int $driverType = shapesUI_shapeDriverOption();
	
	if ($btn == 0)
	{
		if ($type == "combo")
		{
			if ($create)
				$msg += "Combo?";
			else
			{
				$msg = "Process Combo";
				$buttonList = {"Edit", "Delete", "Cancel"};
			}
		}
		else
		{
			if ($create)
			{
				if ($driverType != 4 && $driverType != 5)
					$msg += "Shape Driver?";
				else
				{
					if ($driverType == 4)
						$msg += "RBF ";
					$msg += "Pose?";
				}
			}
			else
			{
				$msg = "Process Shape Driver";
				$buttonList = {"Delete", " Edit Sequence ", "Cancel"};
				if ($type == "rbf" || $type == "pi")
					$buttonList = {"Delete Pose", "Cancel"};
			}
			$driver = 1;
		}
	}
	else
	{
		if (size($gShapes_orderedTargetList) && $gShapes_orderedTargetList[size($gShapes_orderedTargetList) - 1] == $shape)
		{
			if (shapesDriver_getShapeSequencer($shape, {}) != "")
				br_displayMessage -error "Unable to create a combo with a shape which is driven by a sequence";
		}
		$msg += "Combo?";
	}
	
	string $cmd = "confirmDialog -t \"SHAPES\" -m \"" + $msg + "\" -b \"" + stringArrayToString($buttonList, "\" -b \"") + "\" -db \"Cancel\" -cb \"Cancel\" -ds \"Cancel\"";
	string $confirm = `eval $cmd`;
	if ($confirm == "Cancel")
		return;
	
	if ($create)
	{
		if ($driver)
			shapesDriver_createWeightDriver $shape 0 0;
		else
			shapesCombo_createCombo;
	}
	else
	{
		if ($driver)
		{
			if ($confirm == "Delete")
				shapesDriver_deleteWeightDriver $shape 0;
			else if ($confirm == "Delete Pose")
				shapesDriver_removeRbfPose $shape;
			else if ($confirm == " Edit Sequence ")
			{
				$gShapes_sequenceProcess = 1;
				shapesDriver_editDriverSequence $shape;
			}
		}
		else
		{
			if ($confirm == "Delete")
				shapesCombo_removeCombo $shape 0;
			else
			{
				$gShapes_comboProcess = 1;
				shapesCombo_editComboItems $shape;
			}
		}
	}
}


// --------------------------------------------------------------------------------------------------
// shape driver
// --------------------------------------------------------------------------------------------------

global proc shapesDriver_collectJointInfo()
{
	//
	// gather all necessary information for setting up the weight driver
	//
	global string $gShapes_bsNode;
	global string $gShapes_currentSdkAttr;
	global string $gShapes_skinMesh;
	global string $gShapes_orderedDriverList[];
	global string $gShapes_sdkAttrList[];
	
	if ($gShapes_skinMesh == "")
		return;
	
	int $driverType = shapesUI_shapeDriverOption();
	
	string $node[] = `treeView -q -si shpUI_driverTree`;
	shapesList_createOrderedSelectionList $node "driver";
	$node = $gShapes_orderedDriverList;
	
	// make sure that there is only one item processed
	// because the list allows multiple selections
	if (size($node) && $driverType != 4)
	{
		string $temp = $node[0];
		clear $node;
		$node[0] = $temp;
	}
	
	// select the new option for the solver node
	optionMenu -e -sl 1 shpUI_solverNodeOption;
	if ($driverType == 4 || $driverType == 5)
		shapesUI_solverNodeOptionToggle;
	
	if (!size($node) || shapesList_isDriverGroup($node[0]))
	{
		columnLayout -e -en 0 shpUI_driverSettingsColumn;
		$gShapes_sdkAttrList = {};
		return;
	}
	else if (!`columnLayout -q -en shpUI_driverSettingsColumn`)
		columnLayout -e -en 1 shpUI_driverSettingsColumn;
	
	// check if the current selection is a joint or transform node
	// in case a default node is currently selected
	if (`nodeType $node[0]` != "joint" && `nodeType $node[0]` != "transform")
	{
		if ($driverType != 1)
		{
			optionMenu -e -sl 2 shpUI_shapeDriverOption;
			$driverType = 2;
		}
	}
	
	if ($driverType == 2)
	{
		// clear the stored attributes
		$gShapes_sdkAttrList = {};
		$gShapes_currentSdkAttr = "";
		// store all keyable attributes
		$gShapes_sdkAttrList = shapesDriver_getSdkAttributesAndValues($node[0]);
		// refresh the option menu
		shapesDriver_refreshAttributeMenu;
	}
	else if ($driverType == 3)
	{
		// get the parent joint
		if (shapesDriver_getParentFromSelectedJoint() == 0)
			return;
		// guess the axis setting based on the selection
		float $dirValues[];
		shapesDriver_getPrimaryAxis(1, $dirValues);
		// get the joint rotation and set the range slider
		shapesDriver_getMaxAngle $dirValues[1];
		
		floatFieldGrp -e -v1 10 shpUI_distanceMaxField;
	}
	else if ($driverType == 4 || $driverType == 5)
	{
		// get the parent joint
		if (shapesDriver_getParentFromSelectedJoint() == 0)
		{
			optionMenu -e -sl 1 shpUI_solverNodeOption;
			return;
		}
		
		// if a rbf node exists with the name of the selected node
		// select it from the option menu
		string $items[] = `optionMenu -q -ils shpUI_solverNodeOption`;
		for ($i = 0; $i < size($items); $i ++)
		{
			string $label = `menuItem -q -l $items[$i]`;
			string $solver = shapesDriver_getRbfSolverFromListSelection();
			$solver = substitute($gShapes_bsNode + "_", $solver, "");
			if ($label == shapesCommon_removeReferencePath($solver))
			{
				optionMenu -e -sl ($i + 1) shpUI_solverNodeOption;
				textField -e -tx (shapesDriver_getRbfControllerAsString()) shpUI_controlField;
				break;
			}
		}
		
		int $controlled = shapesDriver_isControlled($node);
		
		// auto-fill the controller field if it's still empty in case of a new driver
		string $txt = `textField -q -tx shpUI_controlField`;
		if ($controlled == 0 && ((size($node) == 1 && $txt == "") || (size($node) > 1 && !`gmatch $txt "*,*"`)))
			textField -e -tx (stringArrayToString($node, ",")) shpUI_controlField;
		
		shapesUI_solverNodeOptionToggle;
	}
}


global proc shapesDriver_collectDriverInfo()
{
	//
	// get all relevant information from the weight driver and fill the ui
	//
	global int $gShapes_index;
	global int $gShapes_targetIndex;
	global string $gShapes_driverNodeType;
	global string $gShapes_mirrorDriver;
	global string $gShapes_selectedDriver;
	global string $gShapes_selectedTarget;
	global string $gShapes_orderedDriverList[];
	
	string $nodes[] = shapesDriver_getConnectedWeightDriver($gShapes_selectedTarget);
	
	shapesUI_switchDriverUI;
	shapesUI_togglePoseInfluenceItem 0;
	
	if (!size($nodes))
	{
		shapesUI_addRampWeightsDrivenAttributeOption;
		return;
	}
	
	// clear the search field to make sure that the joint can be found in the list
	shapesUI_clearSearch "driver" 0;
	
	int $wd = 0;
	int $pi = 0;
	if ($gShapes_driverNodeType == "weightDriver")
		$wd = 1;
	else if ($gShapes_driverNodeType == "poseInterpolator")
		$pi = 1;
	
	string $driver;
	if ($wd || $pi)
	{
		$driver = shapesCommon_getShapeNode($nodes[0]);
		string $driverTrans[] = `listRelatives -p $driver`;
		
		string $temp[] = `listRelatives -p $driverTrans[0]`;
		textField -e -tx $temp[0] shpUI_parentField;
		
		int $driverIds[];
		int $type = shapesDriver_getWeightDriverType($driver);
		if (!$type)
			$temp = `listRelatives -p $nodes[1]`;
		else
			$temp = shapesDriver_getWeightDriverDriver($driver, $driverIds);
		$gShapes_selectedDriver = $temp[0];
		
		// check if the found driver is in the joint list
		// if the driver is from a node which is not listed
		// add the driver to the list of drivers
		for ($t in $temp)
		{
			if (!`treeView -q -iex $t shpUI_driverTree`)
				shapesList_storeCustomDriver $t 0;
		}
		
		// in case of multiple rbf drivers:
		// only need to focus on one item since the selection change command
		// for the list selects all driving nodes anyway
		shapesUI_focusOnSelectedItem 0 "shpUI_driverTree" {$gShapes_selectedDriver};
		$gShapes_orderedDriverList = $temp;
		
		if ($wd && !$type)
		{
			int $useAngle = `getAttr ($driver + ".useRotate")`;
			checkBoxGrp -e -v1 $useAngle shpUI_useAngleCheck;
			float $angle = `getAttr ($driver + ".angle")`;
			int $dir = `getAttr ($driver + ".direction")`;
			int $invert = `getAttr ($driver + ".invert")`;
			if ($invert == 1)
				$angle *= -1;
			floatFieldGrp -e -v1 $angle shpUI_rangeField;
			int $useTwist = `getAttr ($driver + ".twist")`;
			checkBoxGrp -e -v1 $useTwist shpUI_useTwistCheck;
			float $centerAngleVal = `getAttr ($driver + ".centerAngle")`;
			floatFieldGrp -e -v1 $centerAngleVal shpUI_centerField;
			optionMenuGrp -e -sl ($dir + 1) shpUI_axisOption;
			int $interpolation = `getAttr ($driver + ".interpolation")` + 1;
			optionMenuGrp -e -sl $interpolation shpUI_interpolateOption;
			float $twistVal = `getAttr ($driver + ".twistAngle")`;
			floatFieldGrp -e -v1 $twistVal shpUI_twistAngleField;
		
			int $useTranslate = `getAttr ($driver + ".useTranslate")`;
			checkBoxGrp -e -v1 $useTranslate shpUI_useDistanceCheck;
			int $grow = `getAttr ($driver + ".grow")`;
			checkBoxGrp -e -v1 $grow shpUI_useIncreaseCheck;
			float $minVal = `getAttr ($driver + ".translateMin")`;
			floatFieldGrp -e -v1 $minVal shpUI_distanceMinField;
			float $maxVal = `getAttr ($driver + ".translateMax")`;
			floatFieldGrp -e -v1 $maxVal shpUI_distanceMaxField;
			
			shapesUI_toggleDriverTranslateOptions;
		}
		else
		{
			int $index = -1;
			if (shapesData_getNonShapeType($gShapes_selectedTarget) != "group")
			{
				string $queryPlug = shapesMain_getQueryPlug($gShapes_selectedTarget);
				string $conn[] = `listConnections -s 1 -d 0 -p 1 $queryPlug`;
				string $items[] = stringToStringArray($conn[0], ".");
				$index = `match "[0-9]+" $items[1]`;
			}
			// in case the rbf group is selected simply get the first poseMode index
			// which usually should be 0 due to the rest pose
			else
			{
				if ($wd)
				{
					int $indexList[] = `getAttr -mi ($driver + ".driverList[" + $driverIds[0] + "].pose")`;
					if (size($indexList))
						$index = $indexList[0];
				}
				else
					$index = 0;
			}
			
			if ($index != -1)
			{
				string $poseAttr = shapesDriver_getPoseAttribute($driver);
				text -e -l ("ID: " + $index) shpUI_rbfIdText;
				if ($wd || ($pi && $index > 0))
				{
					string $modeAttr = "driverList[" + $driverIds[0] + "]." + $poseAttr + "[" + $index + "].poseMode";
					if ($pi)
						$modeAttr = "pose[" + $index + "].poseType";
					int $poseMode = `getAttr ($driver + "." + $modeAttr)` + 1;
					optionMenuGrp -e -sl $poseMode -en 1 shpUI_poseModeOption;
				}
				else
				{
					optionMenuGrp -e -sl 1 -en 0 shpUI_poseModeOption;
				}
				
				// in case of a pose interpolator which has not been created
				// through SHAPES the parent field is empty and all editing
				// should be disabled
				if (`textField -q -tx shpUI_parentField`== "")
				{
					optionMenu -e -sl 1 shpUI_solverNodeOption;
					shapesUI_solverNodeOptionToggle;
				}
			}
			
			shapesUI_togglePoseInfluenceItem 1;
		}
	}
	else if ($gShapes_driverNodeType == "animCurve" && $nodes[1] == "sdk")
	{
		string $plug[] = `listConnections -p 1 -scn 1 ($nodes[0] + ".input")`;
		string $plugItems[] = stringToStringArray($plug[0], ".");
		$driver = $plugItems[0];
		string $attr = $plugItems[1];
		
		// check if the found driver is in the joint list
		// if the driver is from a node which is not listed
		// add the driver to the list of drivers
		if (!`treeView -q -iex $driver shpUI_driverTree`)
			shapesList_storeCustomDriver $driver 0;
		
		shapesUI_focusOnSelectedItem 0 "shpUI_driverTree" {$driver};
		$gShapes_selectedDriver = $driver;
			
		// get values from the sdk curve
		float $valuePair[] = shapesDriver_getSdkValues($nodes[0]);
		if (!size($valuePair))
			return;
		
		shapesDriver_setSdkAttributes $attr $valuePair[0] $valuePair[2];
		
		// get the tangents
		string $tangents[] = `keyTangent -q -itt $nodes[0]`;
		if (size($tangents) == 2)
		{
			int $interpolation = 1;
			if ($tangents[0] == "spline" && $tangents[1] == "flat")
			{
				$interpolation = 2;
				// in case of a negative value range
				// the interpolation types slow/fast need to be switched
				if ($valuePair[0] > $valuePair[2])
					$interpolation = 3;
			}
			else if ($tangents[0] == "flat" && $tangents[1] == "spline")
			{
				$interpolation = 3;
				// in case of a negative value range
				// the interpolation types slow/fast need to be switched
				if ($valuePair[0] > $valuePair[2])
					$interpolation = 2;
			}
			else if ($tangents[0] == "flat" && $tangents[1] == "flat")
				$interpolation = 4;
			optionMenuGrp -e -sl $interpolation shpUI_interpolateOption;
		}
		else
			br_displayMessage -warning ($nodes[0] + " has insufficient keyframe information");
		
		// get the infinity
		int $preInf = `getAttr ($nodes[0] + ".preInfinity")`;
		int $postInf = `getAttr ($nodes[0] + ".postInfinity")`;
		if ($preInf == 0 && $postInf == 0)
			optionMenuGrp -e -sl 1 shpUI_infinityOption;
		else if ($preInf >= 1 && $postInf == 0)
			optionMenuGrp -e -sl 2 shpUI_infinityOption;
		else if ($preInf == 0 && $postInf >= 1)
			optionMenuGrp -e -sl 3 shpUI_infinityOption;
		else if ($preInf >= 1 && $postInf >= 1)
			optionMenuGrp -e -sl 4 shpUI_infinityOption;
	}
	$gShapes_mirrorDriver = $nodes[0];
	
	if ($gShapes_index != -1)
	{
		string $rampPlug = shapesData_getWeightsControllerConnection($gShapes_targetIndex);
		string $rampNode[] = stringToStringArray($rampPlug, ".");
		if ($rampPlug != "" && `gmatch $rampPlug "*.*"` && `optionMenu -q -ex shpUI_rampAttrOption`)
		{
			optionMenu -e -v $rampNode[1] shpUI_rampAttrOption;
		}
	}
}


global proc int shapesDriver_getParentFromSelectedJoint()
{
	//
	// return the parent node of the selected skin joint
	//
	global string $gShapes_selectedDriver;
	global string $gShapes_orderedDriverList[];
	
	string $node[] = $gShapes_orderedDriverList;
	if (!size($node))
		return 0;
	$gShapes_selectedDriver = $node[0];
	
	int $driverType = shapesUI_shapeDriverOption();
	
	if ($driverType < 3 || $driverType > 5)
		return 1;
	
	string $parent[] = `listRelatives -p $node[0]`;
	if (size($parent))
		textField -e -tx $parent[0] shpUI_parentField;
	
	return 1;
}


global proc string shapesDriver_getPrimaryAxis( int $setOption, float $values[] )
{
	//
	// find the primary axis
	// returns the offset node;
	// fills the array with the axis id, the direction (1 or -1)
	// and the offset translation
	//
	string $node[] = `treeView -q -si shpUI_driverTree`;
	
	// go through the children
	// find a child that is offset to the selected joint
	// the translation offset should tell about the axis orientation
	string $offsetNode = shapesDriver_getJointTranslation($node[0]);
	float $pos[];
	if ($offsetNode != "")
		$pos = `getAttr ($offsetNode + ".t")`;
	else
	{
		$pos = `getAttr($node[0] + ".t")`;
		$offsetNode = $node[0];
	}
	
	float $axis = 1;
	float $dir = 1;
	float $offset = 0;
	if ((abs($pos[0]) > abs($pos[1])) && (abs($pos[0]) > abs($pos[2])))
	{
		$axis = 1;
		if ($pos[0] < 0)
			$dir = -1;
		$offset = $pos[0];
	}
	else if (abs($pos[1]) > abs($pos[2]))
	{
		$axis = 2;
		if ($pos[1] < 0)
			$dir = -1;
		$offset = $pos[1];
	}
	else
	{
		$axis = 3;
		if ($pos[2] < 0)
			$dir = -1;
		$offset = $pos[2];
	}
	
	// account for the case where the node has no child
	// and all position values are equal
	if ((abs($pos[0]) == abs($pos[1])) && (abs($pos[0]) == abs($pos[2])))
		$axis = 1;
	
	if ($setOption)
		optionMenuGrp -e -sl $axis shpUI_axisOption;
	
	$values[0] = $axis - 1;
	$values[1] = $dir;
	$values[2] = $offset;
	
	return $offsetNode;
}


global proc shapesDriver_getMaxAngle( int $dir )
{
	//
	// find the axis with the greatest angle
	//
	string $node[] = `treeView -q -si shpUI_driverTree`;
	
	float $value;
	float $rot[] = `getAttr ($node[0] + ".r")`;
	if ((abs($rot[0]) > abs($rot[1])) && (abs($rot[0]) > abs($rot[2])))
		$value = $rot[0];
	else if (abs($rot[1]) > abs($rot[2]))
		$value = $rot[1];
	else
		$value = $rot[2];
	
	// make sure the axis orientation is reflected in the range value for the weight driver
	// the rotation value is made absolut and then multiplied by the direction,
	// which was defined when getting the primary axis
	$value = abs($value) * $dir;
	if ($value == 0)
		$value = 45;
	
	floatFieldGrp -e -v1 $value shpUI_rangeField;
}


global proc string shapesDriver_getJointTranslation( string $node )
{
	//
	// for finding the primary axis for a joint when setting up the weight driver
	// goes recoursively through the children to find a joint with a translation value
	// this is necessary for particular rig joints which are in place on top of each other
	// returns the name of the joint with the offset
	//
	string $rel[] = `listRelatives -c -type "transform" $node`;
	int $endOfChain;
	string $result;
	while ($endOfChain == 0)
	{
		if (size($rel))
		{
			for ($r in $rel)
			{
				float $pos[] = `getAttr ($r + ".t")`;
				float $posSum = floor(($pos[0] + $pos[1] + $pos[2]) * 1000) / 1000;
				if (abs($posSum) > 0.1)
				{
					return $r;
				}
				$result = shapesDriver_getJointTranslation($r);
			}
			$endOfChain = 1;
		}
		else
			$endOfChain = 1;
	}
	if ($result == "")
		return $node;
	
	return $result;
}


global proc string shapesDriver_createWeightDriver( string $target, int $mirror, int $center )
{
	//
	// create the weight driver node and make connections
	//
	global int $gShapes_index;
	global int $gShapes_namespaceExists;
	global string $gShapes_bsNode;
	global string $gShapes_mirrorDriver;
	global string $gShapes_rampPlug;
	global string $gShapes_selectedTarget;
	
	int $driverType = shapesUI_shapeDriverOption();
	
	string $queryPlug;
	if ($gShapes_rampPlug == "")
		$queryPlug = shapesMain_getQueryPlug($target);
	else
	{
		// discontinue if the rbf solver option is selected when creating
		// a driver for the ramp weights node
		if ($driverType == 4 || $driverType == 5)
		{
			string $solverType = "weight driver RBF mode";
			if ($driverType == 5)
				$solverType = "Pose Interpolator";
			br_displayMessage -error ("The " + $solverType + " is currently not supported for driving the ramp weights node");
			return "";
		}
		$queryPlug = $gShapes_rampPlug;
	}
	
	// discontinue if an error occured getting the blend shape node and attribute
	if ($queryPlug == "")
		return "";
	
	// discontinue if the target is already connected
	string $connections[] = `listConnections -s 1 -d 0 $queryPlug`;
	if (size($connections))
		br_displayMessage -error ($queryPlug + " is already connected");
	
	// discontinue if no weight driver should be created
	if ($driverType == 1)
		return "";
	
	string $nodeItem[] = `treeView -q -si shpUI_driverTree`;
	if (!size($nodeItem) || shapesList_isDriverGroup($nodeItem[0]))
		br_displayMessage -error "No driving node selected";
	string $node = $nodeItem[0];
	
	string $driverName;
	
	//-----------------
	// set driven key
	//-----------------
	if ($driverType == 2)
	{
		string $attr = `optionMenu -q -v shpUI_sdkAttrOption`;
		float $range[] = `floatFieldGrp -q -v shpUI_sdkRangeField`;
		int $interpolationVal = `optionMenuGrp -q -sl shpUI_interpolateOption` - 1;
		
		string $tangent[] = {"spline", "spline"};
		if ($interpolationVal == 1)
			$tangent = {"spline", "flat"};
		if ($interpolationVal == 2)
			$tangent = {"flat", "spline"};
		if ($interpolationVal == 3 || $interpolationVal == 4)
			$tangent = {"flat", "flat"};
		
		setDrivenKeyframe -dv $range[0] -v 0 -itt $tangent[0] -ott $tangent[0] -cd ($node + "." + $attr) $queryPlug;
		setDrivenKeyframe -dv $range[1] -v 1 -itt $tangent[1] -ott $tangent[1] -cd ($node + "." + $attr) $queryPlug;
		
		// set the infinity
		int $infValue = `optionMenuGrp -q -sl shpUI_infinityOption`;
		
		$node = $gShapes_bsNode;
		$attr = $target;
		if (shapesData_isDrivenSet($target))
		{
			$node = $target;
			$attr = "value";
		}
		else if ($gShapes_rampPlug != "")
		{
			string $plugItems[] = stringToStringArray($gShapes_rampPlug, ".");
			$node = $plugItems[0];
			$attr = $plugItems[1];
		}
		if ($gShapes_namespaceExists)
			$node = shapesMain_shortenNodePath($node, 0);
		shapesDriver_setCurveInfinity ($node + "_" + $attr) $infValue;
		
		// add the message attribute
		addAttr -at "message" -ln "SHAPES_sdk" ($node + "_" + $attr);
		
		// rename in case of the driver for the rampWeights node
		if ($gShapes_rampPlug != "")
		{
			$driverName = `rename ($node + "_" + $attr) ($node + "_" + $attr + "_WD")`;
			select -cl;
			return $driverName;
		}
	}
	//-----------------
	// weight driver
	//-----------------
	else if ($driverType == 3)
	{
		string $parent = `textField -q -tx shpUI_parentField`;
		if ($parent == "")
			br_displayMessage -error "No parent node defined for the driving joint";
		
		// get the direction
		string $dir[] = {"x", "y", "z"};
		int $mult = 1;
		float $angle = `floatFieldGrp -q -v1 shpUI_rangeField`;
		int $invert;
		if ($angle < 0 && $mirror != 1)
		{
			$invert = 1;
			$mult = -1;
		}
		int $axisVal = `optionMenuGrp -q -sl shpUI_axisOption` - 1;
		
		// create the weight driver
		string $driverShape = `createNode weightDriver`;
		string $driver[] = `listRelatives -p $driverShape`;
		setAttr -l 1 ($driver[0] + ".v");
		
		// create the locator to act as the driver
		string $loc[] = `spaceLocator`;
		parent $loc[0] $node;
		
		// position the nodes
		delete(`pointConstraint $node $driver[0]`);
		delete(`orientConstraint $node $driver[0]`);
		delete(`pointConstraint $node $loc[0]`);
		parent $driver[0] $parent;
		
		// correctly rotate the weight driver if in mirror mode
		if ($mirror == 1)
		{
			select -cl;
			string $joint1 = `joint`;
			delete(`pointConstraint $gShapes_mirrorDriver $joint1`);
			delete(`orientConstraint $gShapes_mirrorDriver $joint1`);
			select -cl;
			string $joint2 = `joint`;
			parent $joint1 $joint2;
			string $joint3[] = `mirrorJoint -myz -mb`;
			delete(`orientConstraint $joint3[0] $driver[0]`);
			delete $joint2;
			if (!`optionVar -q SHAPESBehaviorMirror`)
				$invert = 1 - $invert;
		}
		
		if ($center == 1)
			$invert = 1 - $invert;
		
		// get the center angle field just here because it only present with the weight driver
		int $useAngle = `checkBoxGrp -q -v1 shpUI_useAngleCheck`;
		float $centerAngleVal = `floatFieldGrp -q -v1 shpUI_centerField`;
		float $twistVal = `floatFieldGrp -q -v1 shpUI_twistAngleField`;
		int $useTwist = `checkBoxGrp -q -v1 shpUI_useTwistCheck`;
		int $useTranslate = `checkBoxGrp -q -v1 shpUI_useDistanceCheck`;
		int $grow = `checkBoxGrp -q -v1 shpUI_useIncreaseCheck`;
		float $minVal = `floatFieldGrp -q -v1 shpUI_distanceMinField`;
		float $maxVal = `floatFieldGrp -q -v1 shpUI_distanceMaxField`;
		int $interpolationVal = `optionMenuGrp -q -sl shpUI_interpolateOption` - 1;
		
		int $translateMult = 1;
		if (!$useAngle && $useTranslate)
			$translateMult = 0;
		
		// position the locator along the driver axis
		setAttr ($loc[0] + ".t" + $dir[$axisVal]) (10 * $mult * $translateMult);
		delete(`orientConstraint $node $loc[0]`);
		setAttr ($loc[0] + ".v") 0;
		
		// set the weight driver attributes
		setAttr ($driverShape + ".useRotate") $useAngle;
		setAttr ($driverShape + ".direction") $axisVal;
		setAttr ($driverShape + ".invert") $invert;
		setAttr ($driverShape + ".angle") (abs($angle));
		setAttr ($driverShape + ".centerAngle") $centerAngleVal;
		setAttr ($driverShape + ".interpolation") $interpolationVal;
		setAttr ($driverShape + ".twistAngle") $twistVal;
		setAttr ($driverShape + ".twist") $useTwist;
		setAttr ($driverShape + ".useTranslate") $useTranslate;
		setAttr ($driverShape + ".grow") $grow;
		setAttr ($driverShape + ".translateMin") $minVal;
		setAttr ($driverShape + ".translateMax") $maxVal;
		
		string $attr[] = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"};
		int $skip = 0;
		if ($useTranslate)
			$skip = 3;
		for ($a = $skip; $a < size($attr); $a ++)
			setAttr -l 1 -k 0 ($loc[0] + "." + $attr[$a]);
		
		// add the message attribute
		addAttr -at "message" -ln "SHAPES_wd" $driverShape;
		
		// make the connections
		connectAttr ($driver[0] + ".worldMatrix[0]") ($driverShape + ".readerMatrix");
		connectAttr ($loc[0] + ".worldMatrix[0]") ($driverShape + ".driverMatrix");
		connectAttr ($driverShape + ".outWeight") $queryPlug;
		
		// deactive/active the driver to force an update
		setAttr ($driverShape + ".nodeState") 1;
		refresh;
		setAttr ($driverShape + ".nodeState") 0;
		refresh;
		
		if ($gShapes_rampPlug != "")
		{
			string $plugItems[] = stringToStringArray($gShapes_rampPlug, ".");
			string $name = $plugItems[0] + "_" + $plugItems[1];
			$driverName = $name + "_WD";
			rename $loc[0] ($name + "_loc");
			rename $driver[0] $driverName;
			select -cl;
			return $driverName;
		}
	}
	//-----------------
	// rbf
	//-----------------
	else if ($driverType == 4 || $driverType == 5)
	{
		string $solver = shapesUI_getSelectedNodeOption();
		
		shapesDriver_createRbfPose $solver $target;
		
		$gShapes_selectedTarget = $target;
		shapesList_listBlendShapeTargets 0;
		
		return "";
	}
	
	// rename the weight driver
	$driverName = shapesDriver_renameWeightDriver($target, "");
	
	// only return the driver name if it's a weight driver
	if ($driverType < 3)
		$driverName = "";
	
	if ($mirror == 0)
	{
		$gShapes_selectedTarget = $target;
		shapesList_refreshTargetItem {$target};
	}
	
	select -cl;
	
	return $driverName;
}


global proc string shapesDriver_createRbfNode()
{
	//
	// create the rbf node
	//
	global string $gShapes_bsNode;
	global string $gShapes_mirrorDriver;
	global string $gShapes_selectedTarget;
	global string $gShapes_orderedDriverList[];
	
	int $driverType = shapesUI_shapeDriverOption();
	
	// discontinue if no weight driver should be created
	if ($driverType == 1)
		return "";
	
	string $nodeItem[] = $gShapes_orderedDriverList;
	if (!size($nodeItem) || shapesList_isDriverGroup($nodeItem[0]))
		br_displayMessage -error "No driving node selected";
	
	string $parent = `textField -q -tx shpUI_parentField`;
	if ($parent == "")
		br_displayMessage -error "No parent node defined for the driving joint";
	
	string $control = `textField -q -tx shpUI_controlField`;
	string $ctrls[] = stringToStringArray($control, ",");
	if (shapesDriver_isControlled($nodeItem) && $control == "")
	{
		string $msg = "No control node defined. RBF poses cannot be assumed without a control node.";
		confirmDialog -t "SHAPES" -m $msg -b "Cancel";
		return "";
	}
	else if ($control == "")
	{
		if ($driverType == 4)
			$ctrls = $nodeItem;
		else
			$ctrls[0] = $nodeItem[0];
	}
	
	// create the weight driver
	string $driverShape;
	if ($driverType == 4)
	{
		$driverShape = `createNode weightDriver`;
	}
	else
	{
		$driverShape = shapesPI_createPoseInterpolatorNode();
		shapesPI_addRbfAttributes $driverShape 1;
	}
	
	string $driver[] = `listRelatives -p $driverShape`;
	setAttr -l 1 ($driver[0] + ".v");
	
	// position the nodes
	delete(`pointConstraint $nodeItem[0] $driver[0]`);
	parent $driver[0] $parent;
	
	// $dirValues = {axisId, direction, offset}
	float $dirValues[];
	string $offsetNode = shapesDriver_getPrimaryAxis(0, $dirValues);
	
	if ($driverType == 4)
	{
		// to set the display scale based on the
		// translation value from the next joint
		float $size = abs($dirValues[2]) * 0.6;
		if ($size > 0)
			setAttr ($driverShape + ".iconSize") $size;
		
		// set the weight driver attributes
		setAttr ($driverShape + ".type") 1;
		setAttr ($driverShape + ".twistAxis") $dirValues[0];
		for ($i = 0; $i < size($nodeItem); $i ++)
			setAttr ($driverShape + ".driverList[" + $i + "].pose[0].poseMode") `optionVar -q SHAPESDefaultPoseMode`;
		if ($dirValues[1] == -1)
			setAttr ($driverShape + ".opposite") 1;
	}
	else
	{
		int $ids[] = `getAttr -mi ($driverShape + ".driver")`;
		for ($id in $ids)
			setAttr ($driverShape + ".driver[" + $id + "].driverTwistAxis") $dirValues[0];
	}
	
	// add the message attributes
	addAttr -at "message" -ln "SHAPES_wd" $driverShape;
	shapesCommon_addMessageAttribute($driverShape, "solverGroupMessage", 0);
	shapesCommon_addStringAttribute($driverShape, "solverGroup");
	connectAttr -f -na ($driverShape + ".solverGroupMessage") ($gShapes_bsNode + ".SHAPESSolver");
	
	string $poseAttr = shapesDriver_getPoseAttribute($driverShape);
	
	// make the connections
	for ($i = 0; $i < size($nodeItem); $i ++)
	{
		connectAttr ($nodeItem[$i] + ".worldMatrix[0]") ($driverShape + ".driverList[" + $i + "].driverInput");
		
		shapesDriver_setMatrixAttribute $nodeItem[$i] $driverShape ("driverList[" + $i + "]." + $poseAttr + "[0].poseMatrix");
		shapesDriver_setMatrixAttribute $nodeItem[$i] $driverShape ("driverList[" + $i + "]." + $poseAttr + "[0].poseParentMatrix");
		
		if (size($ctrls))
		{
			connectAttr -f ($ctrls[$i] + ".message") ($driverShape + ".driverList[" + $i + "].controlNode");
			shapesDriver_setRbfControllerPose($ctrls[$i], $driverShape, $i, 0);
		
			if ($driverType == 5)
				shapesPI_connectCustomControl($driverShape, $ctrls[$i]);
		}
	}
	
	// do the renaming directly because naming the rbf solver is different
	// from the regular weight driver since it's not tied to the shape name
	// but the driving node
	string $name = $gShapes_bsNode + "_" + shapesCommon_removeReferencePath($nodeItem[0]);
	string $driverName = $name + "_" + shapesDriver_getDriverNameExtension();
	$driverName = `rename $driver[0] $driverName`;
	
	// create a group for the solver
	string $groupName = shapesUI_addShapeHelperAttribute(1, $driverName, 3);
	setAttr (shapesCommon_getShapeNode($driverName) + ".solverGroup") -type "string" $groupName;
	
	return $driverName;
}


global proc string shapesDriver_mirrorRbfNode()
{
	//
	// mirror the rbf node
	//
	global string $gShapes_bsNode;
	global string $gShapes_rbfGroupParentItem;
	global string $gShapes_rbfParent;
	global string $gShapes_selectedTarget;
	global string $gShapes_orderedDriverList[];
	
	int $driverType = shapesUI_shapeDriverOption();
	
	// discontinue if no weight driver should be created
	if ($driverType == 1)
		return "";
	
	string $nodeItem[] = $gShapes_orderedDriverList;
	if (!size($nodeItem) || shapesList_isDriverGroup($nodeItem[0]))
		br_displayMessage -error "No driving node selected";
	
	string $parent = `textField -q -tx shpUI_parentField`;
	if ($parent == "")
		br_displayMessage -error "No parent node defined for the driving joint";
	
	string $control = `textField -q -tx shpUI_controlField`;
	string $ctrls[] = stringToStringArray($control, ",");
	if (shapesDriver_isControlled($nodeItem) && $control == "")
	{
		string $msg = "No control node defined. RBF poses cannot be assumed without a control node.";
		confirmDialog -t "SHAPES" -m $msg -b "Cancel";
		return "";
	}
	else if ($control == "")
	{
		if ($driverType == 4)
			$ctrls = $nodeItem;
		else
			$ctrls[0] = $nodeItem[0];
	}
	
	// create the weight driver by duplicating the original
	string $solver = shapesUI_getSelectedNodeOption();
	string $driver[] = `duplicate $solver`;
	// rename the solver
	$driver[0] = `rename $driver[0] ($gShapes_bsNode + "_" + shapesCommon_removeReferencePath($nodeItem[0]) + "_" + shapesDriver_getDriverNameExtension())`;
	string $driverShape = shapesCommon_getShapeNode($driver[0]);
	
	// position the nodes
	delete(`pointConstraint $nodeItem[0] $driver[0]`);
	catchQuiet(`parent $driver[0] $parent`);
	
	string $poseAttr = shapesDriver_getPoseAttribute($driverShape);
	
	// make the connections
	for ($i = 0; $i < size($nodeItem); $i ++)
	{
		connectAttr ($nodeItem[$i] + ".worldMatrix[0]") ($driverShape + ".driverList[" + $i + "].driverInput");
		
		shapesDriver_setMatrixAttribute $nodeItem[$i] $driverShape ("driverList[" + $i + "]." + $poseAttr + "[0].poseMatrix");
		shapesDriver_setMatrixAttribute $nodeItem[$i] $driverShape ("driverList[" + $i + "]." + $poseAttr + "[0].poseParentMatrix");
		
		if (size($ctrls))
		{
			connectAttr -f ($ctrls[$i] + ".message") ($driverShape + ".driverList[" + $i + "].controlNode");
			
			if (shapesUI_shapeDriverOption() == 5)
				shapesPI_mirrorConnectDriver $ctrls[$i] $driverShape;
		}
	}
	
	int $isJoint = 0;
	if (`nodeType $nodeItem[0]` == "joint")
		$isJoint = 1;
	
	if (shapesUI_shapeDriverOption() == 4 && $isJoint)
	{
		int $state = `getAttr ($driverShape + ".opposite")`;
		setAttr ($driverShape + ".opposite") (1 - $state);
	}
	
	// also process the parent matrix when mirroring the poses
	// if the parent for both silbing drivers is different
	int $processParentMatrix = 0;
	if ($gShapes_rbfParent != $parent)
		$processParentMatrix = 1;
	$gShapes_rbfParent = "";
	
	shapesDriver_mirrorRbfPoses $driverShape $isJoint $processParentMatrix;
	shapesDriver_mirrorRbfControlPoses $driverShape;
	
	shapesDriver_updateEvaluation $driverShape;
	
	// get the group parent in the target list
	// so when the new rbf group gets created it's not parented underneath
	// the source rbf group but underneath a common parent;
	// for this the parent item gets stored in a global variable which acts as
	// an override for shapesList_autoOrderNewTarget
	string $rbfGroup = shapesDriver_getRbfGroupString($solver);
	if ($rbfGroup == "")
		$gShapes_rbfGroupParentItem = "none";
	else
	{
		$gShapes_rbfGroupParentItem = `treeView -q -ip $rbfGroup shpUI_targetTree`;
		if ($gShapes_rbfGroupParentItem == "")
			$gShapes_rbfGroupParentItem = "none";
	}
	
	// create a group for the solver
	string $groupName = shapesUI_addShapeHelperAttribute(1, $driver[0], 3);
	setAttr (shapesCommon_getShapeNode($driver[0]) + ".solverGroup") -type "string" $groupName;
	
	return $driver[0];
}


global proc shapesDriver_mirrorRbfPoses( string $driver, int $isJoint, int $processParentMatrix )
{
	//
	// mirror the rbf poses
	//
	int $driverIds[] = shapesDriver_getRbfDriverIndices($driver);
	int $isDefault = shapesDriver_isDefaultMatrix($driver + ".driverList[" + $driverIds[0] + "].poseParentMatrix");
	
	string $poseAttr = shapesDriver_getPoseAttribute($driver);
	string $axis = shapesMirror_getAxisString();
	
	for ($driverId in $driverIds)
	{
		int $poseIds[] = `getAttr -mi ($driver + ".driverList[" + $driverId + "]." + $poseAttr)`;
		int $mIds[] = shapesDriver_mirrorRbfGetMatrixIds($axis, $isJoint);
		
		for ($id in $poseIds)
		{
			if ($id != 0)
			{
				float $pm[] = `getAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr  + "[" + $id + "].poseMatrix")`;
				float $ppm[] = `getAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].poseParentMatrix")`;
				
				for ($mId in $mIds)
				{
					$pm[$mId] *= -1;
					if ($processParentMatrix)
						$ppm[$mId] *= -1;
				}
				
				setAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].poseMatrix") -type "matrix" $pm[0] $pm[1] $pm[2] $pm[3] $pm[4] $pm[5] $pm[6] $pm[7] $pm[8] $pm[9] $pm[10] $pm[11] $pm[12] $pm[13] $pm[14] $pm[15];
				if ($driverId != 0 || !$isDefault)
					setAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].poseParentMatrix") -type "matrix" $ppm[0] $ppm[1] $ppm[2] $ppm[3] $ppm[4] $ppm[5] $ppm[6] $ppm[7] $ppm[8] $ppm[9] $ppm[10] $ppm[11] $ppm[12] $ppm[13] $ppm[14] $ppm[15];
			}
		}
	}
}


global proc int[] shapesDriver_mirrorRbfGetMatrixIds( string $axis, int $isJoint )
{
	//
	// return the matrix ids which should be mirrored
	// depending on the axis and node type
	//
	int $mIds[];
	if ($axis == "x")
	{
		if (!$isJoint || !`optionVar -q SHAPESBehaviorMirror`)
			$mIds = {12};
		else
			$mIds = {1, 2, 5, 6, 9, 10, 12};
	}
	else if ($axis == "y")
	{
		if (!$isJoint || !`optionVar -q SHAPESBehaviorMirror`)
			$mIds = {13};
		else
			$mIds = {0, 2, 4, 6, 8, 10, 13};
	}
	else if ($axis == "z")
	{
		if (!$isJoint || !`optionVar -q SHAPESBehaviorMirror`)
			$mIds = {14};
		else
			$mIds = {0, 1, 4, 5, 8, 9, 14};
	}
	return $mIds;
}


global proc shapesDriver_mirrorRbfControlPoses( string $driver )
{
	//
	// mirror the rbf control poses
	//
	string $poseAttr = shapesDriver_getPoseAttribute($driver);
	int $driverIds[] = shapesDriver_getRbfDriverIndices($driver);
	for ($driverId in $driverIds)
	{
		int $poseIds[] = `getAttr -mi ($driver + ".driverList[" + $driverId + "]." + $poseAttr)`;
		string $axis = shapesMirror_getAxisString();
	
		for ($id in $poseIds)
		{
			if ($id != 0)
			{
				string $attrList[] = `getAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].cpa")`;
				float $valueList[] = `getAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].cpv")`;
			
				shapesDriver_mirrorRbfControlPoseValues $attrList $valueList $axis;
				
				eval("setAttr " + $driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].cpv -type \"doubleArray\" " + size($valueList) + " " + shapesArray_floatArrayToString($valueList, " "));
			}
		}
	}
}


global proc shapesDriver_mirrorRbfControlPoseValues( string $attrList[], float $valueList[], string $axis )
{
	//
	// mirror the rbf control pose values
	//
	for ($i = 0; $i < size($attrList); $i ++)
	{
		if ($attrList[$i] == "translateX" && $axis == "x")
			$valueList[$i] *= -1;
		else if ($attrList[$i] == "translateY" && $axis == "y")
			$valueList[$i] *= -1;
		else if ($attrList[$i] == "translateZ" && $axis == "z")
			$valueList[$i] *= -1;
	}
}


global proc shapesDriver_reorderPoseAttributes( string $driver, int $startId )
{
	//
	// reorder the rbf attributes in case the index list is not continuous;
	// the startId is important when working with the pose interpolator
	//
	$driver = shapesCommon_getShapeNode($driver);
	string $poseAttr = shapesDriver_getPoseAttribute($driver);
	
	int $driverIds[] = shapesDriver_getRbfDriverIndices($driver);
	for ($driverId in $driverIds)
	{
		int $poseIds[] = `getAttr -mi ($driver + ".driverList[" + $driverId + "]." + $poseAttr)`;
		int $reorder = 0;
		for ($i = 0; $i < size($poseIds); $i ++)
		{
			if ($i != $poseIds[$i])
			{
				$reorder = 1;
				break;
			}
		}
		
		if (!$reorder)
			return;
		
		int $newId = $startId;
		for ($id in $poseIds)
		{
			if ($id != 0)
			{
				float $pm[] = `getAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].poseMatrix")`;
				string $attrs[] = `getAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].cpa")`;
				float $values[] = `getAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].cpv")`;
				int $order = `getAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].cpro")`;
				int $mode = `getAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "].poseMode")`;
				
				removeMultiInstance -b 1 ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $id + "]");
				
				catchQuiet(`removeMultiInstance -b 1 ($driver + ".poseDrawVector[" + $id + "]")`);
				
				setAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $newId + "].poseMatrix") -type "matrix" $pm[0] $pm[1] $pm[2] $pm[3] $pm[4] $pm[5] $pm[6] $pm[7] $pm[8] $pm[9] $pm[10] $pm[11] $pm[12] $pm[13] $pm[14] $pm[15];
				eval("setAttr " + $driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $newId + "].cpa -type \"stringArray\" " + size($attrs) + " " + stringArrayToString($attrs, " "));
				eval("setAttr " + $driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $newId + "].cpv -type \"doubleArray\" " + size($values) + " " + shapesArray_floatArrayToString($values, " "));
				setAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $newId + "].cpro") $order;
				setAttr ($driver + ".driverList[" + $driverId + "]." + $poseAttr + "[" + $newId + "].poseMode") $mode;
				
				$newId ++;
			}
		}
	}
}


global proc shapesDriver_deleteWeightDriver( string $target, int $isNode )
{
	//
	// delete the weight driver from the selected target
	//
	global string $gShapes_rampPlug;
	
	if ($target == "" && $gShapes_rampPlug == "")
		return;
	
	string $refreshList[];
	if (!$isNode)
	{
		$refreshList = shapesDriver_performDeleteWeightDriver($target);
		shapesUI_switchDriverUI;
	}
	else
	{
		shapesDriver_deleteSolver($target, 1);
	}
	if (size($refreshList))
		shapesList_refreshTargetItem $refreshList;
}


global proc string[] shapesDriver_performDeleteWeightDriver( string $target )
{
	//
	// execute the weight driver removal
	//
	global string $gShapes_bsNode;
	global string $gShapes_rampPlug;
	global string $gShapes_driverPlug[];
	
	string $refreshList[] = {$target};
	
	// in case the given item is a rbf solver group it can be handled differently;
	// this is also necessary in order to prevent a crash on windows which occurs
	// when the blend shape setup gets deleted and a new scene is opened;
	// (a similar related crash occurs when the solver group gets deleted with the
	// button from the channel slider)
	// it's still unclear why this happens but it might be related to the way
	// the RBF weightDriver gets disconnected/removed from the scene
	// *)preventing weightDriverRBF crash on windows
	if (shapesDriver_isRbfSolverGroup($target))
	{
		string $solver = shapesDriver_getRbfSolverFromGroup($target);
		if (shapesDriver_getRbfNodeType(shapesCommon_getShapeNode($solver)) == "weightDriver")
			setAttr ($solver + ".active") 0;
		delete $solver;
		return $refreshList;
	}
	
	string $nodes[] = shapesDriver_getConnectedWeightDriver($target);
	if (size($nodes))
	{
		// shapesDriver_getConnectedWeightDriver returns:
		// - in case of RBF/PI: the driving joint;
		// - in case of vector angle reader: the driver locator;
		// in case of the RBF/PI the joint needs to be discarded or it will get deleted
		int $type = shapesDriver_getWeightDriverType($nodes[0]);
			
		if ($nodes[1] != "" && ($nodes[1] == "sdk" || $nodes[1] == "animCurve" || $type))
			stringArrayRemoveAtIndex(1, $nodes);
		if ($nodes[0] != $gShapes_bsNode)
		{
			string $sequencer;
			string $tgts[];
			string $curves[];
			
			if ($gShapes_rampPlug == "")
			{
				$sequencer = shapesDriver_getShapeSequencer($target, {});
				$tgts = shapesDriver_getShapeSequenceItems($target, "targets");
				$curves = shapesDriver_getShapeSequenceItems($target, "curves");
			}
			
			delete $nodes;
			
			if ($sequencer != "")
			{
				delete $curves;
				// just try to remove the network node
				// but it should have been deleted by deleting the sdk curves
				if (`objExists $sequencer`)
					delete $sequencer;
				$refreshList = $tgts;
			}
		}
		clear $gShapes_driverPlug;
	}
	return $refreshList;
}


global proc string shapesDriver_renameWeightDriver( string $target, string $prevBsName )
{
	//
	// rename the weight driver and the connected nodes according to the driving target
	//
	global string $gShapes_bsNode;
	global string $gShapes_driverNodeType;
	global string $gShapes_mirrorDriver;
	
	string $name = $gShapes_bsNode + "_" + $target;
	string $driverName;
	
	string $nodes[] = shapesDriver_getConnectedWeightDriver($target);
	if (!size($nodes))
		;
	else if ($nodes[0] != $gShapes_bsNode)
	{
		// in case of an rbf solver the target name can be ignored
		int $type = shapesDriver_getWeightDriverType($nodes[0]);
		if ($type)
		{
			$name = substitute($prevBsName, $nodes[0], $gShapes_bsNode);
			$name = substitute(("_" + shapesDriver_getDriverNameExtensionFromName($name)), $name, "");
		}
		
		if ($gShapes_driverNodeType == "weightDriver" || $gShapes_driverNodeType == "animCurve")
		{
			$driverName = $name + "_WD";
			if ($gShapes_driverNodeType == "weightDriver" && !$type)
				rename $nodes[1] ($name + "_loc");
		}
		else if ($gShapes_driverNodeType == "poseInterpolator")
			$driverName = $name + "_PI";
		
		if ($nodes[1] == "animCurve")
		{
			shapesCombo_renameComboMultiplier $target;
			return "";
		}
		rename $nodes[0] $driverName;
		$gShapes_mirrorDriver = $driverName;
		
		// rename the sequencer node
		string $sequencer = shapesDriver_getShapeSequencer($target, {});
		if ($sequencer != "")
			rename $sequencer ("SHAPES_" + $target + "_sequence_net");
	}
	
	shapesCombo_renameComboMultiplier $target;
	
	return $driverName;
}


global proc string[] shapesDriver_getConnectedWeightDriver( string $target )
{
	//
	// find the connected weight driver and the locator node
	//
	global string $gShapes_bsNode;
	global string $gShapes_driverNodeType;
	global string $gShapes_rampPlug;
	
	if ($target == "" && $gShapes_rampPlug == "")
		return {};
	
	$gShapes_driverNodeType = "";
	
	string $queryPlug;
	string $sequencer;
	if ($gShapes_rampPlug == "")
	{
		$queryPlug = shapesMain_getQueryPlug($target);
		
		// usually the source plug to query connections from is the blend shape target channel
		// but in case of a driver sequence the source plug must be on the network node
		// which is the first entry in the combo list
		$sequencer = shapesDriver_getShapeSequencer($target, {});
		if ($sequencer != "")
			$queryPlug = $sequencer + ".driverValue";
	}
	else
		$queryPlug = $gShapes_rampPlug;
	
	// check for a rbf group
	if (shapesData_getNonShapeType($target) == "group")
	{
		string $rbf = shapesDriver_getRbfSolverFromListSelection();
		if (`objExists $rbf`)
		{
			string $rbfShape = shapesCommon_getShapeNode($rbf);
			$gShapes_driverNodeType = `nodeType $rbfShape`;
			int $type;
			if ($gShapes_driverNodeType == "weightDriver")
				$type = shapesDriver_getWeightDriverType($rbf);
			else
			{
				$type = 2;
				shapesPI_performRbfAttributeCheck($rbf);
			}
			optionMenu -e -sl (3 + $type) shpUI_shapeDriverOption;
			
			return {$rbf};
		}
	}
	
	// check if the target is controlled by a combo multiplier
	string $input[] = shapesMain_getTargetInput($queryPlug);
	
	string $plug[];
	string $multNode;
	if ($input[1] == "combo")
	{
		$multNode = $input[0];
		$plug = `listConnections -type "weightDriver" ($multNode + ".i2x")`;
	}
	else
	{
		string $nodeConn[] = `listConnections -sh 1 -s 1 -d 0 $queryPlug`;
		if (size($nodeConn))
		{
			if (`nodeType $nodeConn[0]` == "weightDriver" || `nodeType $nodeConn[0]` == "poseInterpolator")
				$plug[0] = $nodeConn[0];
		}
	}
	
	if (!size($plug))
	{
		if ($input[1] == "combo")
		{
			if (shapesCombo_verifyShapeBasedCombo($multNode))
			{
				$gShapes_driverNodeType = "blendShape";
				optionMenu -e -sl 1 shpUI_shapeDriverOption;
				return {$gShapes_bsNode, ""};
			}
			$plug = `listConnections -type "animCurve" ($multNode + ".i2x")`;
		}
		else
			$plug = `listConnections -s 1 -d 0 -type "animCurve" $queryPlug`;
		
		if (!size($plug))
		{
			optionMenu -e -sl 1 shpUI_shapeDriverOption;
			return {};
		}
		else
		{
			if (size(`listConnections -scn 1 ($plug[0] + ".input")`))
			{
				$gShapes_driverNodeType = "animCurve";
				optionMenu -e -sl 2 shpUI_shapeDriverOption;
			}
			else
			{
				optionMenu -e -sl 1 shpUI_shapeDriverOption;
				return {};
			}
		}
	}
	else
	{
		$gShapes_driverNodeType = shapesDriver_getRbfNodeType($plug[0]);
		int $type = shapesDriver_getWeightDriverType($plug[0]);
		if ($gShapes_driverNodeType == "poseInterpolator")
		{
			$type = 2;
			shapesPI_performRbfAttributeCheck($plug[0]);
		}
		optionMenu -e -sl (3 + $type) shpUI_shapeDriverOption;
	}
	
	string $driver = $plug[0];
	
	if ($gShapes_driverNodeType == "animCurve")
	{
		string $curveType = shapesMain_verifyShapeDriverNode($driver, "sdk", "animCurve");
		if ($curveType == "animCurve")
			optionMenu -e -sl 1 shpUI_shapeDriverOption;
		return {$driver, $curveType};
	}
	
	if (`nodeType $driver` != "transform")
	{
		string $driverTransform[] = `listRelatives -p $driver`;
		$driver = $driverTransform[0];
	}
	int $driverIds[];
	string $loc[] = shapesDriver_getWeightDriverDriver($driver, $driverIds);
	return {$driver, $loc[0]};
}


global proc string[] shapesDriver_getWeightDriverDriver( string $driver, int $ids[] )
{
	//
	// return the drivers for the given weight driver node
	//
	string $nodes[];
	
	int $type = shapesDriver_getWeightDriverType($driver);
	if (!$type)
	{
		string $loc[] = `listConnections -p 1 ($driver + ".driverMatrix")`;
		$loc = stringToStringArray($loc[0], ".");
		$nodes[0] = $loc[0];
	}
	else
	{
		$ids = shapesDriver_getRbfDriverIndices($driver);
		for ($id in $ids)
		{
			string $tmp[] = `listConnections -p 1 ($driver + ".driverList[" + $id + "].driverInput")`;
			$tmp = stringToStringArray($tmp[0], ".");
			$nodes[size($nodes)] = $tmp[0];
		}
	}
	
	return $nodes;
}


global proc string shapesDriver_getRbfSolverFromListSelection()
{
	//
	// returns the rbf solver based on the selected group
	// or target shape
	//
	global string $gShapes_bsNode;
	global string $gShapes_selectedTarget;
	
	if ($gShapes_selectedTarget == "")
		return "";
	
	string $rbfNode;
	string $group = shapesData_getNonShapeType($gShapes_selectedTarget);
	if ($group == "group")
	{
		$rbfNode = shapesDriver_getRbfSolverFromGroup($gShapes_selectedTarget);
	}
	else
	{
		string $plug = shapesMain_getQueryPlug($gShapes_selectedTarget);
		string $input[] = shapesMain_getTargetInput($plug);
		if ($input[1] == "rbf" || $input[1] == "pi")
			$rbfNode = shapesCommon_getTransformNode($input[0]);
	}
	
	return $rbfNode;
}


global proc int[] shapesDriver_performMirrorDriverSettings()
{
	//
	// mirror joint names and settings for creating a mirrored driver
	//
	global int $gShapes_exportProcess;
	global string $gShapes_currentSdkAttr;
	global string $gShapes_orderedDriverList[];
	
	string $node[] = $gShapes_orderedDriverList;
	
	if (!size($node) || shapesList_isDriverGroup($node[0]))
	{
		br_displayMessage -info ("There is no driver node selected in the driver list.");
		return {-1};
	}
	
	int $driverType = shapesUI_shapeDriverOption();
	
	// store the original node name
	// if the node contains a side label the axis will be inverted, but
	// if the node is a center node the axis will remain the same in
	// case of the weight driver
	string $sourceNode = $node[0];
	
	float $sourceRotList[];
	float $sourceAngle;
	float $srcValues[];
	float $sourceStartAngle;
	string $attr;
	int $solverItem;
	// store the source range value before the mirrored node gets selected
	// this is for comparison to check if the mirrored side is posed
	if ($driverType == 2)
	{
		$sourceStartAngle = `floatFieldGrp -q -v1 shpUI_sdkRangeField`;
		$sourceAngle = `floatFieldGrp -q -v2 shpUI_sdkRangeField`;
		// store the source settings
		$srcValues = shapesDriver_getSetShapeDriverOptions("sdk", 1, {});
		$attr = $gShapes_currentSdkAttr;
	}
	else if ($driverType == 3)
	{
		$sourceRotList = `getAttr ($sourceNode + ".rotate")`;
		$sourceAngle = `floatFieldGrp -q -v1 shpUI_rangeField`;
		// store the source settings
		$srcValues = shapesDriver_getSetShapeDriverOptions("weightDriver", 1, {});
		shapesDriver_setGetWeightDriverBlendCurve 1 "";
	}
	else if ($driverType == 4 || $driverType == 5)
	{
		// get the current solver selection to be able to recall this selection
		// since the node will get duplicated for the mirror process
		$solverItem = `optionMenu -q -sl shpUI_solverNodeOption`;
	}
	
	// clear the search field
	shapesUI_clearSearch "driver" 0;
	
	for ($i = 0; $i < size($node); $i ++)
	{
		$node[$i] = shapesMirror_swapSideLabel($node[$i]);
		
		if (`treeView -q -iex $node[$i] shpUI_driverTree`)
			;
		else
		{
			// try to find the node in the scene and add it to the list if needed
			if (`objExists $node[$i]`)
				shapesList_storeCustomDriver $node[$i] 0;
			else
			{
				br_displayMessage -info ($node[$i] + " does not exist in the scene.");
				return {-1};
			}
		}
	}
	
	shapesUI_focusOnSelectedItem 0 "shpUI_driverTree" $node;
	$gShapes_orderedDriverList = $node;
	
	// restore the driver selection which might have changed after storing the new custom driver
	optionMenu -e -sl $driverType shpUI_shapeDriverOption;
	if (($driverType == 4 || $driverType == 5) && $solverItem != "")
		optionMenu -e -sl $solverItem shpUI_solverNodeOption;
	
	int $invert = -1;
	int $center;
	if ($driverType == 2)
	{
		// for the set driven key:
		// the axis value needs to be inverted if the joint is at the center
		// if the joint is on the opposite side, the value doesn't need to be inverted
		if (`nodeType $node[0]` == "joint")
		{
			if ($node[0] != $sourceNode)
			{
				if (`optionVar -q SHAPESBehaviorMirror`)
					$invert = 1;
			}
			else
				$center = 1;
		}
		else if ($node[0] == $sourceNode)
		{
			$invert = 1;
			$center = 1;
		}
		else
		{
			if (!`optionVar -q SHAPESBehaviorMirror`)
				$invert = 1;
		}
	}
	else if ($driverType == 3 || $driverType == 4 || $driverType == 5)
	{
		// the parent name has been already updated due to selecting the mirrored driver
		// now we need to check if the node exists
		if ($driverType == 4 || $driverType == 5)
			shapesDriver_getParentFromSelectedJoint;
		string $parent = `textField -q -tx shpUI_parentField`;
		if (`objExists $parent`)
			;
		else
		{
			br_displayMessage -info ("The parent node for " + $node[0] + " does not exist in the scene.");
			return {-1};
		}
		
		// for the weight driver:
		// if the driver node is at the center the axis value doesn't need to be inverted
		// only invert the value if it's the opposite node, because then the axis will
		// be inverted too
		if ($node[0] == $sourceNode)
		{
			$invert = 1;
			$center = 1;
		}
		
		if ($driverType == 4 || $driverType == 5)
		{
			string $ctrl = `textField -q -tx shpUI_controlField`;
			string $ctrls[] = stringToStringArray($ctrl, ",");
			string $swapped[];
			for ($ctrl in $ctrls)
			{
				$ctrl = shapesMirror_swapSideLabel($ctrl);
				if (`objExists $ctrl`)
					$swapped[size($swapped)] = $ctrl;
				else
				{
					br_displayMessage -info ("The controller node " + $ctrl + " does not exist in the scene.");
					return {-1};
				}
			}
			textField -e -tx (stringArrayToString($swapped, ",")) shpUI_controlField;
		}
	}
	
	int $posed;
	float $targetRotList[];
	float $sourceRot[];
	float $targetRot[];
	if ($driverType == 2)
	{
		// switch to the same attribute of the driver as before
		// it might have changed due to selecting the opposite driver
		if (catch(`eval ("optionMenu -e -v " + $attr + " shpUI_sdkAttrOption")`))
			br_displayMessage -error "The driving attribute cannot be found on the target side";
		// it's not necessary to check for a posed model when working with sdk
		$posed = 1;
	}
	else if ($driverType == 3)
	{
		$targetRotList = `getAttr ($node[0] + ".rotate")`;
		for ($i = 0; $i < 3; $i ++)
		{
			$sourceRot[$i] = shapesCommon_roundFloat($sourceRotList[$i], 3);
			$targetRot[$i] = shapesCommon_roundFloat($targetRotList[$i], 3);
		}
		if ($sourceRot[0] == $targetRot[0] && $sourceRot[1] == $targetRot[1] && $sourceRot[2] == $targetRot[2])
			$posed = 1;
		else if (!`optionVar -q SHAPESBehaviorMirror`)
		{
			for ($i = 0; $i < 3; $i ++)
			{
				$sourceRot[$i] = shapesCommon_roundFloat(abs($sourceRot[$i]), 2);
				$targetRot[$i] = shapesCommon_roundFloat(abs($targetRot[$i]), 2);
			}
			if ($sourceRot[0] == $targetRot[0] && $sourceRot[1] == $targetRot[1] && $sourceRot[2] == $targetRot[2])
				$posed = 1;
		}
	}
	else if ($driverType == 4 || $driverType == 5)
	{
		// if the mirrored solver already exists
		// simple shape mirroring can be assumed
		// and checking the rest pose is not necessary
		if (`objExists (shapesMirror_swapAllSideLabels(shapesUI_getSelectedNodeOption()))`)
			$posed = 1;
		else
			$posed = shapesDriver_checkRestPose();
	}
	
	if (!$posed && !$gShapes_exportProcess)
	{
		string $msg = "The model is not posed.\n\nTo mirror a shape with a shape driver the target side needs to be posed to match the pose of the source side.";
		if ($driverType == 4)
			$msg = "The model is not in its rest pose.";
		confirmDialog	-t "SHAPES"
						-m $msg
						-b "OK"
						-db "OK"
						-cb "OK"
						-ds "OK";
		return {-1};
	}
	
	if ($driverType == 2)
	{
		shapesDriver_getSetShapeDriverOptions "sdk" 0 $srcValues;
		floatFieldGrp -e -v1 ($sourceStartAngle * $invert) shpUI_sdkRangeField;
		floatFieldGrp -e -v2 ($sourceAngle * $invert) shpUI_sdkRangeField;
	}
	else if ($driverType == 3)
	{
		shapesDriver_getSetShapeDriverOptions "weightDriver" 0 $srcValues;
		floatFieldGrp -e -v1 ($sourceAngle * $invert) shpUI_rangeField;
	}
	
	return {1, $center};
}


global proc float[] shapesDriver_getSetShapeDriverOptions( string $type, int $read, float $values[] )
{
	//
	// reads or sets the options and values for the shape driver
	//
	if ($read)
	{
		if ($type == "weightDriver")
		{
			float $axisVal = `optionMenuGrp -q -sl shpUI_axisOption`;
			float $angle = `floatFieldGrp -q -v1 shpUI_rangeField`;
			float $twistVal = `floatFieldGrp -q -v1 shpUI_twistAngleField`;
			float $interpolate = `optionMenuGrp -q -sl shpUI_interpolateOption`;
			float $centerAngleVal = `floatFieldGrp -q -v1 shpUI_centerField`;
			float $useTwist = `checkBoxGrp -q -v1 shpUI_useTwistCheck`;
			int $useAngle = `checkBoxGrp -q -v1 shpUI_useAngleCheck`;
			int $useTranslate = `checkBoxGrp -q -v1 shpUI_useDistanceCheck`;
			int $grow = `checkBoxGrp -q -v1 shpUI_useIncreaseCheck`;
			float $minVal = `floatFieldGrp -q -v1 shpUI_distanceMinField`;
			float $maxVal = `floatFieldGrp -q -v1 shpUI_distanceMaxField`;
			$values = {$axisVal, $angle, $twistVal, $interpolate, $centerAngleVal, $useTwist, $useAngle, $useTranslate, $grow, $minVal, $maxVal};
		}
		else
		{
			float $attr = `optionMenu -q -sl shpUI_sdkAttrOption`;
			float $range[] = `floatFieldGrp -q -v shpUI_sdkRangeField`;
			float $interpolate = `optionMenuGrp -q -sl shpUI_interpolateOption`;
			float $infValue = `optionMenuGrp -q -sl shpUI_infinityOption`;
			$values = {$attr, $range[0], $range[1], $interpolate, $infValue};
		}
	}
	else
	{
		if ($type == "weightDriver")
		{
			optionMenuGrp -e -sl $values[0] shpUI_axisOption;
			floatFieldGrp -e -v1 $values[1] shpUI_rangeField;
			floatFieldGrp -e -v1 $values[2] shpUI_twistAngleField;
			optionMenuGrp -e -sl $values[3] shpUI_interpolateOption;
			floatFieldGrp -e -v1 $values[4] shpUI_centerField;
			checkBoxGrp -e -v1 $values[5] shpUI_useTwistCheck;
			checkBoxGrp -e -v1 $values[6] shpUI_useAngleCheck;
			checkBoxGrp -e -v1 $values[7] shpUI_useDistanceCheck;
			checkBoxGrp -e -v1 $values[8] shpUI_useIncreaseCheck;
			floatFieldGrp -e -v1 $values[9] shpUI_distanceMinField;
			floatFieldGrp -e -v1 $values[10] shpUI_distanceMaxField;
		}
		else
		{
			optionMenu -e -sl $values[0] shpUI_sdkAttrOption;
			floatFieldGrp -e -v1 $values[1] -v2 $values[2] shpUI_sdkRangeField;
			optionMenuGrp -e -sl $values[3] shpUI_interpolateOption;
			optionMenuGrp -e -sl $values[4] shpUI_infinityOption;
		}
	}
	return $values;
}


global proc string shapesDriver_setGetWeightDriverBlendCurve( int $read, string $driver )
{
	//
	// get/set the weight driver blend curve when mirroring or exporting;
	// in read mode the node is not given but queried here if not exporting;
	// in write mode (export/transfer) the node is given
	//
	global float $gShapes_blendCurveValues[];
	global string $gShapes_selectedTarget;
	
	string $attrString;
	
	if ($read)
	{
		if ($driver == "")
		{
			if ($gShapes_selectedTarget == "")
				return "";
	
			string $queryPlug = shapesMain_getQueryPlug($gShapes_selectedTarget);
	
			string $input[] = shapesMain_getTargetInput($queryPlug);
			if (!size($input))
				return "";
	
			$driver = $input[0];
		}
		
		float $values[];
		int $indices[] = `getAttr -mi ($driver + ".blendCurve")`;
		for ($id in $indices)
		{
			$values[size($values)] = `getAttr ($driver + ".blendCurve[" + $id + "].blendCurve_Position")`;
			$values[size($values)] = `getAttr ($driver + ".blendCurve[" + $id + "].blendCurve_FloatValue")`;
			$values[size($values)] = `getAttr ($driver + ".blendCurve[" + $id + "].blendCurve_Interp")`;
		}
		
		$gShapes_blendCurveValues = $values;
	}
	else
	{
		int $indices[] = `getAttr -mi ($driver + ".blendCurve")`;
		for ($i = 0; $i < size($indices); $i ++)
		{
			if ($indices[$i] != 0)
				removeMultiInstance -b 1 ($driver + ".blendCurve[" +  $indices[$i] + "]");
		}
		
		int $id = 0;
		for ($i = 0; $i < size($gShapes_blendCurveValues); $i += 3)
		{
			$attrString += "setAttr " + $driver + ".blendCurve[" + $id + "].blendCurve_Position " + $gShapes_blendCurveValues[$i] + ";\n";
			$attrString += "setAttr " + $driver + ".blendCurve[" + $id + "].blendCurve_FloatValue " + $gShapes_blendCurveValues[$i + 1] + ";\n";
			$attrString += "setAttr " + $driver + ".blendCurve[" + $id + "].blendCurve_Interp " + $gShapes_blendCurveValues[$i + 2] + ";\n";
			$id ++;
		}
	}
	return $attrString;
}


// --------------------------------------------------------------------------------------------------
// rbf solver
// --------------------------------------------------------------------------------------------------

global proc int shapesDriver_restPoseIsSet()
{
	//
	// check if the rest pose has been set
	//
	string $solver = shapesUI_getSelectedNodeOption();
	string $poseAttr = shapesDriver_getPoseAttribute($solver);
	
	int $ids[] = shapesDriver_getRbfDriverIndices($solver);
	float $mat[] = `getAttr ($solver + ".driverList[" + $ids[0] + "]." + $poseAttr + "[0].poseParentMatrix")`;
	float $sum = 0;
	for ($m in $mat)
		$sum += $m;
	
	int $result = 0;
	
	if ($sum > 0.0)
		$result = 1;
	
	return $result;
}


global proc shapesDriver_setRestPose()
{
	//
	// set the rest pose for the current weight driver node
	//
	string $driver = shapesUI_getSelectedNodeOption();
	string $poseAttr = shapesDriver_getPoseAttribute($driver);
	int $ids[];
	string $nodes[] = shapesDriver_getWeightDriverDriver($driver, $ids);
	
	for ($i = 0; $i < size($ids); $i ++)
	{
		shapesDriver_setMatrixAttribute $nodes[$i] $driver ("driverList[" + $ids[$i] + "]." + $poseAttr + "[0].poseMatrix");
		shapesDriver_setMatrixAttribute $nodes[$i] $driver ("driverList[" + $ids[$i] + "]." + $poseAttr + "[0].poseParentMatrix");
	}
	
	if (shapesUI_shapeDriverOption() == 5)
		shapesPI_addNeutralPoses $driver;
	
	shapesDriver_updateEvaluation $driver;
	
	shapesUI_toggleRestPoseButton;
}


global proc shapesDriver_setMatrixAttribute( string $node, string $driver, string $attr )
{
	string $sourceAttr = "worldMatrix";
	if (`gmatch $attr "*Parent*"`)
		$sourceAttr = "parentMatrix";
	
	connectAttr -f ($node + "." + $sourceAttr + "[0]") ($driver + "." + $attr);
	refresh;
	disconnectAttr ($node + "." + $sourceAttr + "[0]") ($driver + "." + $attr);
}


global proc shapesDriver_resetRestPose()
{
	//
	// reset the rest pose for the current weight driver node
	//
	string $driver = shapesUI_getSelectedNodeOption();
	string $poseAttr = shapesDriver_getPoseAttribute($driver);
	int $ids[] = shapesDriver_getRbfDriverIndices($driver);
	
	for ($i = 0; $i < size($ids); $i ++)
	{
		setAttr ($driver + ".driverList[" + $ids[$i] + "]." + $poseAttr + "[0].poseMatrix") -type "matrix" 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
		setAttr ($driver + ".driverList[" + $ids[$i] + "]." + $poseAttr + "[0].poseParentMatrix") -type "matrix" 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
	}
	
	if (shapesUI_shapeDriverOption() == 5)
		shapesPI_deleteNeutralPose $driver;
	
	shapesDriver_updateEvaluation $driver;
	
	// activate the set rest pose button
	shapesUI_toggleRestPoseButton;
}


global proc int shapesDriver_checkRestPose()
{
	//
	// check if the current pose is the rest pose
	//
	string $driver = shapesUI_getSelectedNodeOption();
	string $poseAttr = shapesDriver_getPoseAttribute($driver);
	int $ids[] = shapesDriver_getRbfDriverIndices($driver);
	float $poseMat[] = `getAttr ($driver + ".driverList[" + $ids[0] + "]." + $poseAttr + "[0].poseMatrix")`;
	float $driverMat[] = `getAttr ($driver + ".driverList[" + $ids[0] + "].driverInput")`;
	int $unmatched = 0;
	for ($i = 0; $i < size($poseMat); $i ++)
	{
		if (!equivalentTol($poseMat[$i], $driverMat[$i], 0.00000001))
			$unmatched ++;
	}
	if ($unmatched)
		return 0;
	
	return 1;
}


global proc int shapesDriver_isDefaultMatrix( string $attr )
{
	//
	// check if the current matrix is a default matrix
	// (translation gets ignored)
	//
	float $mat[] = `getAttr $attr`;
	float $compareMat[] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
	int $unmatched = 0;
	for ($i = 0; $i < 12; $i ++)
	{
		if ($mat[$i] != $compareMat[$i])
			$unmatched ++;
	}
	if ($unmatched)
		return 0;
	
	return 1;
}


global proc shapesDriver_updateEvaluation( string $driver )
{
	//
	// forces the solver to update the evaluation after
	// adding or editing poses
	//
	string $shape = shapesCommon_getShapeNode($driver);
	if (`nodeType $shape` == "weightDriver")
	{
		setAttr ($driver + ".evaluate") 0;
		setAttr ($driver + ".evaluate") 1;
	}
}


global proc shapesDriver_createNewSolver()
{
	//
	// creates a new weight driver node as an rbf solver
	//
	shapesDriver_createRbfNode;
	shapesUI_refreshSolverMenu;
	shapesDriver_collectJointInfo;
}


global proc string[] shapesDriver_deleteSolver( string $driver, int $dialog )
{
	//
	// deletes the rbf solver
	//
	global string $gShapes_bsNode;
	global string $gShapes_selectedTarget;
	
	if ($dialog)
	{
		int $driverType = shapesUI_shapeDriverOption();
	
		string $msg = "Delete RBF solver?";
		if ($driverType == 5)
			$msg = "Delete Pose Interpolator?";
		if (!shapesCommon_confirmWindow($msg, "Delete"))
			return {};
	}
	
	string $refreshList[];
	
	string $conn[] = `listConnections -s 0 -d 1 -p 1 -c 1 ($driver + ".output")`;
	for ($c = 0; $c < size($conn); $c += 2)
	{
		disconnectAttr $conn[$c] $conn[$c + 1];
		setAttr $conn[$c + 1] 0;
		string $items[] = stringToStringArray($conn[$c + 1], ".");
		// add the connected blend shape target to the update list
		if ($items[0] == $gShapes_bsNode)
			$refreshList[size($refreshList)] = $items[1];
		// add the connected driven set to the update list
		else
			$refreshList[size($refreshList)] = $items[0];
	}
	
	string $transform[] = `listRelatives -p $driver`;
	
	string $group = shapesDriver_getRbfGroupString($transform[0]);
	if (stringArrayContains($group, shapesData_getTargetList()))
	{
		shapesAction_performRemoveBlendShapeTarget -1 (shapesData_getListIndex($group)) 0 1;
		$gShapes_selectedTarget = "";
	}
	
	catchQuiet(`delete $transform[0]`);
	
	shapesList_listBlendShapeTargets 0;
	shapesUI_switchDriverUI;
	
	return $refreshList;
}


global proc int shapesDriver_getWeightDriverType( string $driver )
{
	//
	// returns of the given node is set to
	// vector angle (0) or rbf (1)
	//
	if ($driver == "")
		return 0;
	
	string $shape = shapesCommon_getShapeNode($driver);
	
	if ($shape == "")
		return 0;
	
	if (`nodeType $shape` == "weightDriver")
		return (`getAttr ($driver + ".type")`);
	else if (`nodeType $shape` == "poseInterpolator")
		return 1;
	return 0;
}


global proc string shapesDriver_getRbfNodeType( string $driver )
{
	//
	// returns of the given node is of type weight driver or pose interpolator
	//
	string $shape = shapesCommon_getShapeNode($driver);
	return `nodeType $shape`;
}


global proc int[] shapesDriver_getRbfDriverIndices( string $driver )
{
	//
	// return only used ids of the rbf solver
	//
	if (!`objExists $driver`)
		return {};
	
	int $allIds[] = `getAttr -mi ($driver + ".driverList")`;
	int $ids[];
	for ($id in $allIds)
	{
		string $conn[] = `listConnections -s 1 -d 0 ($driver + ".driverList[" + $id + "].driverInput")`;
		if (size($conn))
			$ids[size($ids)] = $id;
	}
	return $ids;
}


global proc shapesDriver_createRbfPose( string $solver, string $target )
{
	//
	// adds a new pose to the rbf solver
	//
	
	// first get the group name of the driver;
	// if this is the first pose the group will be empty and the group name
	// can be constructed from the blend shape node and solver name;
	// for any additional pose the group name can be resolved by tracking connections;
	// if for the first pose this query would happen be after setting up the pose
	// the connection would be already there but the parent of the target in the list
	// wouldn't be the solver group, which is important for getting the group name;
	// the solution is to query the group before setting up the connections
	string $group = shapesDriver_getRbfGroupString($solver);
	
	int $driverIds[];
	string $nodes[] = shapesDriver_getWeightDriverDriver($solver, $driverIds);
	string $poseAttr = shapesDriver_getPoseAttribute($solver);
	
	int $id;
	if (shapesDriver_getRbfNodeType($solver) == "weightDriver")
		$id = shapesCommon_findEmptyMultiIndex($solver + ".driverList[" + $driverIds[0] + "]." + $poseAttr);
	else
		$id = shapesPI_addPose($solver, $target);
	
	for ($i = 0; $i < size($nodes); $i ++)
	{
		shapesDriver_setMatrixAttribute $nodes[$i] $solver ("driverList[" + $driverIds[$i] + "]." + $poseAttr + "[" + $id + "].poseMatrix");
		shapesDriver_setMatrixAttribute $nodes[$i] $solver ("driverList[" + $driverIds[$i] + "]." + $poseAttr + "[" + $id + "].poseParentMatrix");
		
		int $poseMode = `optionVar -q SHAPESDefaultPoseMode`;
		if (`optionVar -q SHAPESPoseModeFromSelected`)
			$poseMode = `optionMenuGrp -q -sl shpUI_poseModeOption` - 1;
		setAttr ($solver + ".driverList[" + $driverIds[$i] + "]." + $poseAttr + "[" + $id + "].poseMode") $poseMode;
		if (shapesDriver_getRbfNodeType($solver) == "poseInterpolator")
			setAttr ($solver + ".pose[" + $id + "].poseType") $poseMode;
	}
	
	// store the controller pose
	string $ctrlNode[] = shapesDriver_getRbfController();
	if (size($ctrlNode))
	{
		for ($i = 0; $i < size($driverIds); $i ++)
			shapesDriver_setRbfControllerPose($ctrlNode[$i], $solver, $driverIds[$i], $id);
	}
	
	string $queryPlug = shapesMain_getQueryPlug($target);
	connectAttr ($solver + ".output[" + $id + "]") $queryPlug;
	
	shapesDriver_updateEvaluation $solver;
	
	// parent the shape to the rbf group if it exists and
	// if it's not already part of the group
	string $itemParent;
	if (`treeView -q -iex $target shpUI_targetTree`)
		$itemParent = `treeView -q -ip $target shpUI_targetTree`;
	if (stringArrayContains($group, shapesData_getTargetList()) && $itemParent != $group)
		shapesList_setNewParent($target, $group);
}


global proc shapesDriver_removeRbfPose( string $target )
{
	//
	// removes the current pose from the rbf solver
	//
	global string $gShapes_selectedTarget;
	
	$gShapes_selectedTarget = $target;
	string $solver = shapesDriver_getRbfSolverFromListSelection();
	
	string $queryPlug = shapesMain_getQueryPlug($target);
	string $conn[] = `listConnections -s 1 -d 0 -p 1 -c 1 $queryPlug`;
	string $driver[] = stringToStringArray($conn[1], ".");
	int $index = `match "[0-9]+" $driver[1]`;
	int $driverIds[] = shapesDriver_getRbfDriverIndices($driver[0]);
	string $poseAttr = shapesDriver_getPoseAttribute($driver[0]);
	
	disconnectAttr $conn[1] $conn[0];
	for ($id in $driverIds)
		removeMultiInstance -b 1 ($driver[0] + ".driverList[" + $id + "]." + $poseAttr + "[" + $index + "]");
	if (`nodeType $driver[0]` == "weightDriver")
		removeMultiInstance -b 1 ($driver[0] + ".poseDrawVector[" + $index + "]");
	setAttr $conn[0] 0;
	
	if (`nodeType $driver[0]` == "poseInterpolator")
		shapesPI_deletePose $driver[0] $target;
	
	shapesDriver_updateEvaluation $driver[0];
	
	//$gShapes_selectedTarget = $target;
	shapesList_refreshTargetItem {$target};
}


global proc int shapesDriver_rbfHasPoses( string $solver )
{
	//
	// returns true if the solver has output connections
	//
	
	if ($solver == "")
		return -1;
	
	string $conn[] = `listConnections -s 0 -d 1 -p 1 ($solver + ".output")`;
	if (size($conn))
		return 1;
	else
		return 0;
}


global proc string shapesDriver_getRbfGroupString( string $driver )
{
	//
	// return the rbf group name based on the given weightDriver node
	//
	string $group = "";
	string $solver = shapesCommon_getShapeNode($driver);
	if (`attributeQuery -ex -n $solver "solverGroup"`)
	{
		$group = `getAttr ($solver + ".solverGroup")`;
	}
	else
	{
		// if there are no connections yet the group is named after the solver
		return shapesDriver_createRbfGroupString($driver);
	}
	
	return $group;
}


global proc string shapesDriver_createRbfGroupString( string $driver )
{
	//
	// create the rbf group name based on the given weightDriver node
	//
	global string $gShapes_bsNode;
	
	// remove the blend shape name from the string
	string $group = substitute($gShapes_bsNode + "_", $driver, "");
	$group = substitute("_WD", $group, "_RBF");
	return $group;
}


global proc string[] shapesDriver_getRbfController()
{
	//
	// return the current rbf control node
	//
	string $driver = shapesUI_getSelectedNodeOption();
	int $ids[] = shapesDriver_getRbfDriverIndices($driver);
	string $controller[];
	for ($id in $ids)
	{
		string $conn[] = `listConnections -s 1 -d 0 ($driver + ".driverList[" + $id + "].controlNode")`;
		$controller[size($controller)] = $conn[0];
	}
	return $controller;
}


global proc string[] shapesDriver_getRbfSolvers( string $bsNode )
{
	//
	// return the list of solvers connected to the blend shape node
	//
	return (`listConnections -s 1 -d 0 ($bsNode + ".SHAPESSolver")`);
}


global proc string shapesDriver_getRbfSolverFromGroup( string $group )
{
	//
	// return the rbf solver which belongs to the given group
	//
	global string $gShapes_bsNode;
	
	string $solver;
	string $solvers[] = shapesDriver_getRbfSolvers($gShapes_bsNode);
	for ($s in $solvers)
	{
		string $grp = `getAttr ($s + ".solverGroup")`;
		if ($grp == $group)
		{
			$solver = $s;
			break;
		}
	}
	return $solver;
}


global proc shapesDriver_updateSolverGroupString( string $oldName, string $newName )
{
	//
	// updates the solver group name on the rbf solver
	// when the group gets renamed
	//
	string $solver = shapesDriver_getRbfSolverFromGroup($oldName);
	setAttr ($solver + ".solverGroup") -type "string" $newName;
}


global proc int shapesDriver_isRbfSolverGroup( string $group )
{
	//
	// return true if the given group is a solver group
	//
	if (shapesDriver_getRbfSolverFromGroup($group) == "")
		return 0;
	return 1;
}


global proc shapesDriver_updateExistingRbfGroups()
{
	//
	// updates pre-existing rbf nodes and pose interpolators
	// regarding their group assignements which allows for renaming
	// of the solver groups whithout breaking any functionality
	//
	global string $gShapes_bsNode;
	
	string $wd[] = `listConnections -s 1 -d 0 -type weightDriver $gShapes_bsNode`;
	string $rbf[];
	for ($driver in $wd)
	{
		if (shapesDriver_getWeightDriverType($driver))
			$rbf[size($rbf)] = $driver;
	}
	string $pi[] = `listConnections -s 1 -d 0 -type poseInterpolator $gShapes_bsNode`;
	string $solvers[] = stringArrayCatenate($rbf, $pi);
	$solvers = stringArrayRemoveDuplicates($solvers);
	for ($s in $solvers)
	{
		int $outs[] = `getAttr -mi ($s + ".output")`;
		string $group[];
		for ($o in $outs)
		{
			string $conn[] = `listConnections -s 0 -d 1 -p 1 ($s + ".output[" + $o + "]")`;
			if (size($conn))
			{
				string $items[] = stringToStringArray($conn[0], ".");
				if (`treeView -q -iex $items[1] shpUI_targetTree`)
					$group[size($group)] = `treeView -q -ip $items[1] shpUI_targetTree`;
			}
		}
		$group = stringArrayRemoveDuplicates($group);
		if (!size($group))
			br_displayMessage -error ("The pose shapes for " + $s + " are not placed in any group. Group assignment failed.");
		else if (size($group) > 1)
			br_displayMessage -warning ("The pose shapes for " + $s + " are placed in more than one group. Assigning group " + $group[0] + " as the solver group.");
		
		string $shape = shapesCommon_getShapeNode($s);
		shapesCommon_addMessageAttribute($shape, "solverGroupMessage", 0);
		shapesCommon_addStringAttribute($shape, "solverGroup");
		connectAttr -f -na ($shape + ".solverGroupMessage") ($gShapes_bsNode + ".SHAPESSolver");
		setAttr ($shape + ".solverGroup") -type "string" $group[0];
		
		br_displayMessage -info ("Updated group assignments on " + $s + ".");
	}
}


global proc string shapesDriver_getRbfControllerAsString()
{
	//
	// return the control nodes as a comma separated string
	//
	return stringArrayToString(shapesDriver_getRbfController(), ",");
}


global proc shapesDriver_setRbfControllerPose( string $control, string $solver, int $driverIndex, int $index )
{
	//
	// stores the current controller pose with the rbf pose
	//
	string $poseAttr = shapesDriver_getPoseAttribute($solver);
	
	string $attrs[] = `listAttr -k -w -u -s $control`;
	if (!size($attrs))
	{
		string $msg = "No keyable attributes found on the selected controller.\n\nAdd default translation and rotation attributes?";
		if (!shapesCommon_confirmWindow($msg, "OK"))
		{
			br_displayMessage -warning "No controller pose set";
			return;
		}
		$attrs = {"translateX", "translateY", "translateZ", "rotateX", "rotateY", "rotateZ"};
	}
	string $attrList[];
	float $valueList[];
	for ($attr in $attrs)
	{
		if (!`getAttr -l ($control + "." + $attr)`)
		{
			float $value = `getAttr ($control + "." + $attr)`;
			$attrList[size($attrList)] = $attr;
			$valueList[size($valueList)] = $value;
		}
	}
	
	eval("setAttr " + $solver + ".driverList[" + $driverIndex + "]." + $poseAttr + "[" + $index + "].cpa -type \"stringArray\" " + size($attrList) + " " + stringArrayToString($attrList, " "));
	eval("setAttr " + $solver + ".driverList[" + $driverIndex + "]." + $poseAttr + "[" + $index + "].cpv -type \"doubleArray\" " + size($valueList) + " " + shapesArray_floatArrayToString($valueList, " "));
	setAttr ($solver + ".driverList[" + $driverIndex + "]." + $poseAttr + "[" + $index + "].cpro") `getAttr ($control + ".rotateOrder")`;
}


global proc int shapesDriver_restoreControllerPose()
{
	//
	// tweak button callback for restoring the controller pose
	// returns true if the driver is a rbf or pose interpolator node
	//
	global string $gShapes_selectedTarget;
	
	int $driverType = shapesUI_shapeDriverOption();
	
	if ($driverType != 4 && $driverType != 5)
		return 0;
	
	string $solver = shapesUI_getSelectedNodeOption();
	
	string $queryPlug = shapesMain_getQueryPlug($gShapes_selectedTarget);
	string $conn[] = `listConnections -s 1 -d 0 -p 1 $queryPlug`;
	string $items[] = stringToStringArray($conn[0], ".");
	int $index = `match "[0-9]+" $items[1]`;
	
	string $control[] = shapesDriver_getRbfController();
	int $ids[] = shapesDriver_getRbfDriverIndices($solver);
	for ($i = 0; $i < size($control); $i ++)
		shapesDriver_getRbfControllerPose $control[$i] $solver $ids[$i] $index;
	
	return 1;
}


global proc shapesDriver_getRbfControllerPose( string $control, string $solver, int $driverIndex, int $index )
{
	//
	// restores the controller pose for the rbf pose
	//
	string $poseAttr = shapesDriver_getPoseAttribute($solver);
	
	string $attrList[] = `getAttr ($solver + ".driverList[" + $driverIndex + "]." + $poseAttr + "[" + $index + "].cpa")`;
	float $valueList[] = `getAttr ($solver + ".driverList[" + $driverIndex + "]." + $poseAttr + "[" + $index + "].cpv")`;
	int $srcOrder = `getAttr ($solver + ".driverList[" + $driverIndex + "]." + $poseAttr + "[" + $index + "].cpro")`;
	int $destOrder = `getAttr ($control + ".rotateOrder")`;
	
	float $rotVal[] = {0.0, 0.0, 0.0};
	int $hasRotation = 0;
	int $xId = -1;
	int $yId = -1;
	int $zId = -1;
	for ($i = 0; $i < size($attrList); $i ++)
	{
		if ($attrList[$i] == "rotateX")
		{
			$rotVal[0] = $valueList[$i];
			$hasRotation ++;
			$xId = $i;
		}
		else if ($attrList[$i] == "rotateY")
		{
			$rotVal[1] = $valueList[$i];
			$hasRotation ++;
			$yId = $i;
		}
		else if ($attrList[$i] == "rotateZ")
		{
			$rotVal[2] = $valueList[$i];
			$hasRotation ++;
			$zId = $i;
		}
	}
	
	if ($hasRotation == 3)
	{
		float $newRot[] = eval("br_reorderRotation -ir " + shapesArray_floatArrayToString($rotVal, " ") + " -io " + $srcOrder + " -oo " + $destOrder);
		if ($xId != -1)
			$valueList[$xId] = $newRot[0];
		if ($yId != -1)
			$valueList[$yId] = $newRot[1];
		if ($zId != -1)
			$valueList[$zId] = $newRot[2];
	}
	
	
	for ($i = 0; $i < size($attrList); $i ++)
	{
		if (`attributeExists $attrList[$i] $control` && !`getAttr -l ($control + "." + $attrList[$i])`)
			catchQuiet(`setAttr ($control + "." + $attrList[$i]) $valueList[$i]`);
	}
}


global proc	string shapesDriver_getDriverNameExtension()
{
	//
	// get the extension for the node name based on the type of solver
	//
	int $driverType = shapesUI_shapeDriverOption();
	
	string $ext = "WD";
	if ($driverType == 5)
		$ext = "PI";
	
	return $ext;
}


global proc	string shapesDriver_getDriverNameExtensionFromName( string $driver )
{
	//
	// get the extension from the node name based on the type of solver
	//
	int $driverType = shapesUI_shapeDriverOption();
	
	string $ext = "";
	if (`gmatch $driver "*_WD*"`)
		$ext = "WD";
	else if (`gmatch $driver "*_PI*"`)
		$ext = "PI";
	
	return $ext;
}


global proc	string shapesDriver_getPoseAttribute( string $driver )
{
	//
	// get the pose attribute name based on the type of solver
	//
	string $attr = "pose";
	if (shapesDriver_getRbfNodeType($driver) == "poseInterpolator")
		$attr = "poseList";
	
	return $attr;
}


global proc	int shapesDriver_isControlled( string $nodes[] )
{
	//
	// return, if the selected shape drivers are controlled
	// by another node, like constraint or other connection
	//
	int $result = 0;
	
	for ($node in $nodes)
	{
		string $conn[] = `listConnections -s 1 -d 0 -p 1 -c 1 -scn 1 $node`;
		if (size($conn))
		{
			string $attrs[] = {"translate", "rotate"};
			for ($i = 0; $i < size($conn); $i += 2)
			{
				string $items[] = stringToStringArray($conn[$i], ".");
				string $driver[] = stringToStringArray($conn[$i + 1], ".");
				string $type = `nodeType $driver[0]`;
				if (!`gmatch $type "*animCurve*"` && `nodeType $driver[0]` != "character")
				{
					for ($attr in $attrs)
					{
						if (`gmatch $items[1] ("*" + $attr + "*")` && !`gmatch $items[1] ("*rotateOrder*")`)
						{
							$result += 1;
							break;
						}
					}
				}
			}
		}
	}
	
	if ($result > 1)
		$result = 1;
	
	return $result;
}


global proc shapesDriver_validateWeightDriverRBFValues()
{
	//
	// checks the pose matrices of the current RBF solver
	// and reports matching poses in case the decomposition failed
	//
	string $sel[] = `ls -sl`;
	if (!size($sel))
		return;
	
	string $shape = shapesCommon_getShapeNode($sel[0]);
	
	if ($shape == "" || `nodeType $shape` != "weightDriver")
		return;
	
	string $info = "\nSolver : " + $shape + "\n";
	for ($i = 0; $i < size($shape) + 9; $i ++)
		$info += "-";
	$info += "\n";
	
	int $error = 0;
	
	int $dIds[] = `getAttr -mi ($shape + ".dl")`;
	for ($dId in $dIds)
	{
		if (size(`listConnections ($shape + ".dl[" + $dId + "].driverInput")`))
		{
			$info += "Driver " + $dId + ":\n";
			int $pIds[] = `getAttr -mi ($shape + ".dl[" + $dId + "].pose")`;
			float $sum[];
			for ($i = 0; $i < size($pIds); $i ++)
			{
				float $mat[] = `getAttr ($shape + ".dl[" + $dId + "].p[" + $pIds[$i] + "].pmat")`;
				string $matString;
				for ($j = 0; $j < size($mat); $j ++)
				{
					float $val = (floor($mat[$j] * 1000)) / 1000.0;
					$matString += $val + " ";
					$sum[$i] += $val;
				}
				$info += "\tPose " + $pIds[$i] + " : " + $matString + "\n";
			}
			
			for ($i = 0; $i < size($pIds); $i ++)
			{
				for ($j = 0; $j < size($pIds); $j ++)
				{
					if (($i != $j) && $sum[$i] == $sum[$j])
					{
						$info += "\tPose " + $pIds[$i] + " matches pose " + $pIds[$j] + "\n";
						$error ++;
					}
				}
			}
		}
	}
	
	print $info;
	
	if ($error)
		br_displayMessage -warning "The RBF solver has matching poses. See script editor for details.";
}


// --------------------------------------------------------------------------------------------------
// shape driver actions
// --------------------------------------------------------------------------------------------------

global proc shapesDriver_selectDriver()
{
	//
	// select the weight driver of the target
	//
	global string $gShapes_selectedTarget;
	
	string $nodes[] = shapesDriver_getConnectedWeightDriver($gShapes_selectedTarget);
	if (!size($nodes))
		return;
	select $nodes[0];
}


global proc shapesDriver_attachDetachDriver( int $mode, int $ignore, int $sliderDrag )
{
	//
	// connect/disconnect the driving node to freely adjust the blendshape slider
	//
	global int $gShapes_unlinkSlider;
	global int $gShapes_updateValueState;
	global string $gShapes_bsNode;
	global string $gShapes_selectedTarget;
	global string $gShapes_driverPlug[];
	
	if ($ignore && !$gShapes_unlinkSlider)
	{
		$gShapes_unlinkSlider = 1;
		if (!$mode)
			br_displayMessage -info "The shape driver has been unlinked. Select the target item again to re-link.";
	}
	else if ($ignore && $gShapes_unlinkSlider)
		$gShapes_unlinkSlider = 0;
	
	// reset the status to force a re-connect if a new shape is selected to make sure
	// that the connection returns to it's default
	if ($mode && $ignore)
		$gShapes_unlinkSlider = 0;
	
	string $queryPlug = $gShapes_bsNode + "." + $gShapes_selectedTarget;
	// get the query plug
	// when a mesh gets loaded this method is called through main.getSelection;
	// at this point $gShapes_index is not yet set and causes an error
	// so we need to check if there is actually an attribute to query
	if (!$mode)
	{
		if ($gShapes_selectedTarget != "")
			$queryPlug = shapesMain_getQueryPlug($gShapes_selectedTarget);
		else
			return;
	}
	
	// disconnect
	if (!$mode)
	{
		$gShapes_updateValueState = 0;
		string $plug[] = `listConnections -s 1 -d 0 -p 1 $queryPlug`;
		if (size($plug))
		{
			string $type = `nodeType $plug[0]`;
			// no need to disconnect if the driver is an animation curve
			if (!`gmatch $type "animCurve*"`)
			{
				$gShapes_driverPlug = {$plug[0], $queryPlug};
				catchQuiet(`disconnectAttr $plug[0] $queryPlug`);
			}
		}
	}
	// connect
	else
	{
		$gShapes_updateValueState = 1;
		if (`iconTextCheckBox -q -v shpUI_filterLiveCheck`)
			shapesJob_updateDisplayValue;
		if (!$gShapes_unlinkSlider)
		{
			if (size($gShapes_driverPlug))
			{
				catchQuiet(`connectAttr $gShapes_driverPlug[0] $gShapes_driverPlug[1]`);
				clear $gShapes_driverPlug;
			}
		}
	}
	// update the other selected targets when the slider is dragged or has been changed
	if ($sliderDrag)
		shapesMain_matchSelectedTargetValues;
}


global proc shapesDriver_showHideWeightDriver( string $attr, int $state )
{
	//
	// show/hide all weight drivers in the scene
	//
	string $wd[] = `ls -type weightDriver`;
	for ($node in $wd)
		setAttr ($node + "." + $attr) $state;
}


global proc shapesDriver_setShapeDriverAttribute( string $item, string $label )
{
	//
	// sets the connected weightDriver attributes or sdk values based on the changed
	// user settings in the shape driver attribute section
	//
	global int $gShapes_index;
	global int $gShapes_targetIndex;
	global string $gShapes_currentSdkAttr;
	global string $gShapes_rampPlug;
	global string $gShapes_selectedTarget;
	global string $gShapes_orderedTargetList[];
	
	string $queryPlug;
	string $driverItems[];
	string $solverTargets[];
	int $solverIds[];
	string $poseAttr;
	
	int $driverType = shapesUI_shapeDriverOption();
	
	// in case of a rbf solver the node name doesn't need to be found from
	// the driving target shape but can be read from the option menu
	if (($driverType == 4 || $driverType == 5) &&
		`optionMenu -q -sl shpUI_solverNodeOption` != 1)
	{
		$driverItems[0] = shapesCommon_getShapeNode(shapesUI_getSelectedNodeOption());
		if ($driverType == 4)
			$driverItems[1] = "wd";
		else if ($driverType == 5)
			$driverItems[1] = "pi";
		
		if (size($gShapes_orderedTargetList) > 1)
			$solverTargets = shapesList_getTargetListRbfSelection($solverIds);
		
		$poseAttr = shapesDriver_getPoseAttribute($driverItems[0]);
	}
	// for all other shape drivers get the node via the target shape connections
	else
	{
		if ($gShapes_selectedTarget == "" && $gShapes_rampPlug == "")
			return;
		
		if ($gShapes_rampPlug == "")
			$queryPlug = shapesMain_getQueryPlug($gShapes_selectedTarget);
		else
			$queryPlug = $gShapes_rampPlug;
	
		$driverItems = shapesMain_getTargetInput($queryPlug);
		if (!size($driverItems))
			return;
	}
	
	string $node = $driverItems[0];
	string $type = $driverItems[1];
	
	if ($type == "sdks")
	{
		string $conn[] = `listConnections -s 1 -d 0 -sh 1 ($node + ".driverValue")`;
		if (`nodeType $conn[0]` == "weightDriver")
			$type = "wd";
		else if (`gmatch (nodeType($conn[0])) "*animCurve*"`)
			$type = "sdk";
		$node = $conn[0];
	}
	
	if ($type == "combo")
		;
	
	if ($type == "wd" || $type == "pi")
	{
		int $invert;
		float $value;
		string $piAttr;
		string $attrList[];
		string $piAttrList[];
		if (	$label == "direction" ||
				$label == "interpolation" ||
				$label == "poseMode" ||
				$label == "twistAxis")
		{
			$value = `optionMenuGrp -q -sl $item` - 1;
			
			if ($label == "poseMode")
			{
				if (!size($solverIds))
				{
					string $items[] = stringToStringArray(`text -q -l shpUI_rbfIdText`, " ");
					if (size($items) > 1)
					{
						int $id = $items[1];
						$label = $poseAttr + "[" + $id + "]." + $label;
						$piAttr = "pose[" + $id + "].poseType";
					}
					else
						return;
				}
				else
				{
					$label = $poseAttr + "[0].poseMode";
					for ($i = 0; $i < size($solverIds); $i ++)
					{
						$attrList[$i] = $poseAttr + "[" + $solverIds[$i] + "].poseMode";
						if ($solverIds[$i] != 0)
							$piAttrList[$i] = "pose[" + $solverIds[$i] + "].poseType";
					}
				}
			}
			else if ($label == "twistAxis" && $type == "pi")
			{
				int $ids[] = `getAttr -mi ($node + ".driver")`;
				for ($i = 0; $i < size($ids); $i ++)
					$piAttrList[$i] = "driver[" + $ids[$i] + "].driverTwistAxis";
			}
		}
		else if (	$label == "angle" ||
					$label == "centerAngle" ||
					$label == "twistAngle" ||
					$label == "translateMin" ||
					$label == "translateMax")
		{
			float $vList[] = `floatFieldGrp -q -v $item`;
			$value = $vList[0];
			if ($label == "angle" && $value < 0)
			{
				$value = abs($value);
				$invert = 1;
			}
		}
		else if (	$label == "twist" ||
					$label == "useRotate" ||
					$label == "useTranslate" ||
					$label == "grow")
			$value = `checkBoxGrp -q -v1 $item`;
		
		if (`gmatch $label "*poseMode*"`)
		{
			int $ids[] = shapesDriver_getRbfDriverIndices($node);
			for ($id in $ids)
			{
				if (!size($attrList))
					setAttr ($node + ".driverList[" + $id + "]." + $label) $value;
				else
				{
					for ($attr in $attrList)
						setAttr ($node + ".driverList[" + $id + "]." + $attr) $value;
				}
			}
		}
		else
			setAttr ($node + "." + $label) $value;
		if (`nodeType $node` == "poseInterpolator")
		{
			if ($piAttr != "")
				setAttr ($node + "." + $piAttr) $value;
			else if (size($piAttrList))
			{
				for ($attr in $piAttrList)
					setAttr ($node + "." + $attr) $value;
			}
		}
		
		if ($label == "angle")
			setAttr ($node + ".invert") $invert;
	}
	else if ($type == "sdk")
	{
		if ($label == "minMax")
		{
			float $values[] = `floatFieldGrp -q -v $item`;
			// get the key time values from the sdk curve for comparison
			// this is needed to set the correct keyframes
			int $indexList[] = `getAttr -mi ($node + ".ktv")`;
			float $timeValue1[] = `getAttr ($node + ".ktv[" + $indexList[0] + "]")`;
			float $timeValue2[] = `getAttr ($node + ".ktv[" + $indexList[1] + "]")`;
			// if the first listed keyframe is the one which defines the end state of the sdk (1)
			// the value list needs to be reversed so that the max/end value comes first
			if ($timeValue1[1] > 0)
			{
				float $temp[];
				for ($i = size($values) - 1; $i >= 0; $i --)
					$temp[size($temp)] = $values[$i];
				$values = $temp;
			}
			keyframe -a -o "over" -index 0 -fc $values[0] $node;
			// if the new value for the first keyframe is greater than the value of the second
			// the key listing gets reordered and the second keyframe to be edited will be listed first
			int $keyId = 1;
			if ($values[0] > $timeValue1[0] && $values[0] > $timeValue2[0])
				$keyId = 0;
			keyframe -a -o "over" -index $keyId -fc $values[1] $node;
		}
		else if ($label == "interpolation")
		{
			int $value = `optionMenuGrp -q -sl $item` - 1;
			string $tangent[] = {"spline", "spline"};
			if ($value == 1)
				$tangent = {"spline", "flat"};
			if ($value == 2)
				$tangent = {"flat", "spline"};
			if ($value == 3)
				$tangent = {"flat", "flat"};
			// if the max value is actually negative the keyframe for this pose
			// is actually listed first and makes it necessary to reverse the tangent list
			float $values[] = `floatFieldGrp -q -v shpUI_sdkRangeField`;
			if ($values[1] < 0)
			{
				string $tan[];
				for ($i = size($tangent) - 1; $i >= 0; $i --)
					$tan[size($tan)] = $tangent[$i];
				$tangent = $tan;
			}
			keyTangent -index 0 -itt $tangent[0] -ott $tangent[0] $node;
			keyTangent -index 1 -itt $tangent[1] -ott $tangent[1] $node;
		}
		else if ($label == "infinity")
		{
			int $value = `optionMenuGrp -q -sl $item`;
			shapesDriver_setCurveInfinity $node $value;
		}
		else if ($label == "attribute")
		{
			string $connect[] = `listConnections -s 1 -d 0 -scn 1 -p 1 -c 1 $node`;
			string $conversion[] = `listConnections -type "unitConversion" $node`;
			string $connectItems1[] = stringToStringArray($connect[0], ".");
			string $connectItems2[] = stringToStringArray($connect[1], ".");
			connectAttr -f ($connectItems2[0] + "." + $gShapes_currentSdkAttr) ($node + "." + $connectItems1[1]);
			// delete the previous conversion node if any
			if (size($conversion))
				delete $conversion;
		}
	}
	
	if ($label == "ramp")
	{
		string $rampPlug = shapesData_getWeightsControllerConnection($gShapes_targetIndex);
		string $rampNodeItems[] = stringToStringArray($rampPlug, ".");
		if (`nodeType $rampNodeItems[0]` == "rampWeights" && size($rampNodeItems) > 1)
		{
			string $connect[] = `listConnections -s 1 -d 0 -scn 1 -p 1 -c 1 $rampPlug`;
			if (size($connect))
			{
				string $conversion[] = `listConnections -type "unitConversion" $rampPlug`;
				disconnectAttr $connect[1] $connect[0];
				string $driven = $rampNodeItems[0] + "." + `optionMenu -q -v shpUI_rampAttrOption`;
				connectAttr -f $connect[1] $driven;
				// delete the previous conversion node if any
				if (size($conversion))
					delete $conversion;
			}
		}
	}
}


// --------------------------------------------------------------------------------------------------
// sdk attributes
// --------------------------------------------------------------------------------------------------

global proc float[] shapesDriver_getSdkValues( string $node )
{
	//
	// return the sdk values for the given curve
	//
	// get the number of keys for the sdk curve
	int $indexList[] = `getAttr -mi ($node + ".ktv")`;
	if (size($indexList) > 2)
	{
		br_displayMessage -warning "Only two set driven keyframes are currently supported";
		return {};
	}
	if (size($indexList) == 1)
	{
		br_displayMessage -warning "The set driven key curve has only one keyframe";
		return {};
	}
	float $valuePair[];
	for ($k in $indexList)
	{
		// get the time value pair for the current index
		float $values[] = `getAttr ($node + ".ktv[" + $k + "]")`;
		if (!size($valuePair))
			$valuePair = $values;
		else
		{
			if ($values[1] > $valuePair[1])
			{
				for ($v in $values)
					$valuePair[size($valuePair)] = $v;
			}
			else
			{
				for ($v = 0; $v < size($values); $v ++)
					shapesArray_floatArrayInsertAtIndex($v, $valuePair, $values[$v]);
			}
		}
	}
	return $valuePair;
}


global proc shapesDriver_refreshAttributeMenu()
{
	//
	// build a new option menu with the given driver attributes
	//
	global string $gShapes_currentSdkAttr;
	global string $gShapes_sdkAttrList[];
	
	setParent shpUI_sdkForm;
	
	if (`optionMenu -ex shpUI_sdkAttrOption`)
		deleteUI shpUI_sdkAttrOption;
	
	optionMenu -cc ("shapesDriver_sdkSetCurrentAttribute 1") shpUI_sdkAttrOption;
	
	// if there are no attributes create the default list
	if (!size($gShapes_sdkAttrList))
		$gShapes_sdkAttrList = {"None", "0"};
	
	// get all atrributes for sorting
	string $attrList[];
	for ($i = 0; $i < size($gShapes_sdkAttrList); $i += 2)
		$attrList[size($attrList)] = $gShapes_sdkAttrList[$i];
	$attrList = sort($attrList);
	
	int $maxValue;
	string $maxAttr = "None";
	for ($attr in $attrList)
	{
		int $id = shapesArray_stringArrayFind($attr, 0, $gShapes_sdkAttrList);
		float $value = $gShapes_sdkAttrList[$id + 1];
		menuItem -l $attr -p shpUI_sdkAttrOption;
		// compare the values and store the attribute with the highest/lowest value
		// this attribute gets selected in the option menu
		if (abs($value) > $maxValue)
		{
			$maxValue = abs($value);
			$maxAttr = $attr;
		}
	}
	
	formLayout	-e
				
				-af shpUI_sdkAttrOption "top" 0
				-af shpUI_sdkAttrOption "bottom" 0
				-af shpUI_sdkAttrOption "right" 29
				
				-ac shpUI_sdkAttrOption "left" 23 "shpUI_sdkAttrLabel"
				
				shpUI_sdkForm;
	
	setParent ..;
	
	if ($gShapes_currentSdkAttr == "")
		$gShapes_currentSdkAttr = $maxAttr;
	
	if ($maxAttr != "None")
	{
		int $id = shapesArray_stringArrayFind($gShapes_currentSdkAttr, 0, $gShapes_sdkAttrList);
		float $value = $gShapes_sdkAttrList[$id + 1];
		shapesDriver_setSdkAttributes $gShapes_currentSdkAttr 0.0 $value;
	}
}


global proc shapesDriver_sdkSetCurrentAttribute( int $update )
{
	//
	// store the currently selected sdk attribute until the driver changes
	//
	global string $gShapes_currentSdkAttr;
	global string $gShapes_sdkAttrList[];
	
	$gShapes_currentSdkAttr = `optionMenu -q -v shpUI_sdkAttrOption`;
	// if the call does not come from selecting an attribute but rather from either
	// reading the sdk curve values or setting the value previously the field needs no update
	if ($update)
	{
		int $id = shapesArray_stringArrayFind($gShapes_currentSdkAttr, 0, $gShapes_sdkAttrList);
		float $value = $gShapes_sdkAttrList[$id + 1];
		floatFieldGrp -e -v2 $value shpUI_sdkRangeField;
		shapesDriver_setShapeDriverAttribute "shpUI_sdkAttrOption" "attribute";
	}
}


global proc shapesDriver_setSdkAttributes( string $attr, float $min, float $max )
{
	//
	// set the sdk attributes
	//
	optionMenu -e -v $attr shpUI_sdkAttrOption;
	floatFieldGrp -e -v1 $min -v2 $max shpUI_sdkRangeField;
	shapesDriver_sdkSetCurrentAttribute 0;
}


global proc string[] shapesDriver_getSdkAttributesAndValues( string $node )
{
	//
	// read the keyable attributes from the channelbox
	// and return them as a list
	//
	string $attrValues[];
	string $attrs[] = `listAttr -k $node`;
	string $attrsCB[] = `listAttr -cb $node`;
	
	if (size($attrsCB))
		$attrs = stringArrayCatenate($attrs, $attrsCB);
	
	string $skipAttrs[] = {"", "string", "float2", "float3", "double2", "double3", "long2", "long3", "short2", "short3", "message"};
	
	if (size($attrs) != 0)
	{
		for ($a in $attrs)
		{
			// make sure no compound attributes get added
			// i.e. weightList.weights from a bend node
			if (size(stringToStringArray($a, ".")) == 1)
			{
				// make sure that no string or double/triple attribute is processed
				string $attrType;
				$attrType = `getAttr -type ($node + "." + $a)`;
				if (!stringArrayContains($attrType, $skipAttrs))
				{
					float $value = `getAttr ($node + "." + $a)`;
					if ($value == 0)
					{
						if (!`optionVar -q SHAPESIgnoreZeroChannels`)
						{
							$attrValues[size($attrValues)] = $a;
							$attrValues[size($attrValues)] = $value;
						}
					}
					else
					{
						$attrValues[size($attrValues)] = $a;
						$attrValues[size($attrValues)] = $value;
					}
				}
			}
		}
	}
	else
		br_displayMessage -warning "The selected driver has no keyable attributes to display.";
	
	return $attrValues;
}


global proc shapesDriver_setCurveInfinity( string $node, float $value )
{
	//
	// get the curve infinity values based on the selected option menu item
	//
	int $preInf;
	int $postInf;
	// pre infinity
	if ($value == 2)
		$preInf = 1;
	// post infinity
	if ($value == 3)
		$postInf = 1;
	// pre/post infinity
	if ($value == 4)
	{
		$preInf = 1;
		$postInf = 1;
	}
	setAttr ($node + ".preInfinity") $preInf;
	setAttr ($node + ".postInfinity") $postInf;
}


// --------------------------------------------------------------------------------------------------
// sequence editing
// --------------------------------------------------------------------------------------------------

global proc shapesDriver_editDriverSequence( string $target )
{
	//
	// initializes the editing of the driver sequence
	// gets the current shape driver and existing sequence targets
	// and populates the slider frame
	//
	global float $gShapes_sequenceMax;
	global string $gShapes_currentSequenceTarget;
	
	string $master[];
	string $sequencer = shapesDriver_getShapeSequencer($target, $master);
	if ($sequencer == "" && !size($master))
		return;
	
	// clear the target selection and the slider frame
	treeView -e -cs shpUI_targetTree;
	shapesMain_buildTargetSlider;
	
	// disable the general ui and show the combo ui
	shapesUI_showEditComboUI 1;
	shapesCombo_editComboToggleUI 0;
	frameLayout -e -l "Sequence" -cl 0 shpUI_sliderFrame;
	
	$gShapes_currentSequenceTarget = $target;
	$gShapes_sequenceMax = shapesDriver_getSequenceEndValue($master[0]);
	
	string $tgts[] = shapesDriver_getShapeSequenceItems($target, "targets");
	string $valueString[] = shapesDriver_getShapeSequenceItems($target, "values");
	float $values[];
	for ($vs in $valueString)
		$values[size($values)] = $vs;
	if (size($tgts))
	{
		shapesDriver_addSequenceSlider $tgts $values 0;
		$gShapes_currentSequenceTarget = $tgts[size($tgts) - 1];
	}
	else
		shapesDriver_addSequenceSlider {$target} {1} 0;
	
	// set the curve option
	string $tan[] = shapesDriver_getShapeSequenceItems($target, "tangents");
	if (!size($tan))
		$tan[0] = "1";
	eval ("optionMenu -e -sl " + $tan[0] + " shpUI_sequenceCurveOption");
}


global proc shapesDriver_addRemoveSequenceItems( int $add )
{
	//
	// add/remove the selected items in the list to the current channel sliders
	//
	string $selection[] = `treeView -q -si shpUI_targetTree`;
	if (!size($selection))
		return;
	
	if ($add)
	{
		float $values[];
		for ($s in $selection)
			$values[size($values)] = 0.5;
		shapesDriver_addSequenceSlider $selection $values 1;
	}
	else
	{
		string $sliderList[] = shapesDriver_getSequenceSlider();
		for ($item in $selection)
		{
			string $layout = "";
			string $target = "";
			float $value = 0;
			
			for ($slider in $sliderList)
			{
				string $items[] = stringToStringArray($slider, ",");
				if ($items[1] == $item)
				{
					$layout = $items[0];
					$target = $items[1];
					$value = $items[2];
				}
			}
			if ($value == 1)
				br_displayMessage -error "The sequence end shape cannot be removed";
			else
			{
				if ($layout != "")
				{
					deleteUI $layout;
					// reset the target color
					treeView -e -lbc $target -1 -1 -1 shpUI_targetTree;
				}
			}
		}
	}
	treeView -e -cs shpUI_targetTree;
}


global proc shapesDriver_addSequenceSlider( string $targets[], float $values[], int $checkRelationship )
{
	//
	// adds a new sequence slider for the selected target
	//
	global float $gShapes_sequenceMax;
	global float $gShapes_driverCol[];
	global float $gShapes_targetCol[];
	global string $gShapes_currentSequenceTarget;
	
	setParent shpUI_sliderFrame;
	
	string $sliderList[] = shapesDriver_getSequenceSlider();
	
	for ($i = 0; $i < size($targets); $i ++)
	{
		int $add = 1;
		for ($slider in $sliderList)
		{
			string $items[] = stringToStringArray($slider, ",");
			if ($items[1] == $targets[$i])
				$add = 0;
		}
		
		if ($add)
		{
			// check if the target is part of the current sequence;
			// if the target has been removed and then about to be added again
			// it has the sdks type (because of the button icon) and can't be added again;
			// the check needs to be performed so that a previously removed target can be added again
			int $itemOfCurrent = 0;
			string $tgts[] = shapesDriver_getShapeSequenceItems($targets[$i], "targets");
			if (size($tgts) && $tgts[size($tgts) - 1] == $gShapes_currentSequenceTarget)
				$itemOfCurrent = 1;
			
			// check if the added target is not already part of a sequence;
			// can be part of a sequence when checkRelationship is true,
			// which is necessary for listing the targets when entering edit mode
			string $input[] = shapesMain_getTargetInput(shapesMain_getQueryPlug($targets[$i]));
			if ($input[1] != "sdks" || !$checkRelationship || $itemOfCurrent)
			{
				int $enable = 1;
				
				// make sure that the main target is disabled
				if ($values[$i] == 1)
					$enable = 0;
				
				shapesUI_expandParentItem $targets[$i];
				
				rowLayout -nc 3 -cat 1 "left" 0 -adj 3;
				
					text -l $targets[$i] -w 140 -al "left";
					string $valueField = `floatField -pre 3 -v (shapesCommon_roundFloat(($gShapes_sequenceMax * $values[$i]), 2)) -w 60 -en $enable`;
					string $slider = `floatSliderGrp	-l ""
														-f 1
														-v $values[$i]
														-en $enable
														-min 0
														-max 1
														-pre 3
														-cw3 0 50 40
														-co3 0 5 5
														-ct3 "left" "both" "right"`;
					
					floatField -e -cc ("shapesDriver_updateSequenceSlider " + $slider + " " + $valueField) $valueField;
					floatSliderGrp -e -cc ("shapesDriver_updateSequenceDriverValue " + $slider + " " + $valueField) $slider;
					
					setParent ..;
				
				if ($enable)
					treeView -e -lbc $targets[$i] $gShapes_driverCol[0] $gShapes_driverCol[1] $gShapes_driverCol[2] shpUI_targetTree;
				else
					treeView -e -lbc $targets[$i] $gShapes_targetCol[0] $gShapes_targetCol[1] $gShapes_targetCol[2] shpUI_targetTree;
			}
			else
				br_displayMessage -warning ("Unable to add the target \"" + $targets[$i] + "\" because it is already part of another sequence");
		}
	}
}


global proc shapesDriver_orderSequence()
{
	//
	// orders the sequence sliders
	//
	string $sliderList[] = shapesDriver_getSequenceSlider();
	
	// sort the list by values
	string $values[];
	for ($slider in $sliderList)
	{
		string $items[] = stringToStringArray($slider, ",");
		$values[size($values)] = $items[2];
	}
	$values = sort($values);
	
	string $sorted[];
	for ($v in $values)
	{
		for ($slider in $sliderList)
		{
			string $items[] = stringToStringArray($slider, ",");
			if ($items[2] == $v)
				$sorted[size($sorted)] = $slider;
		}
	}
	$sliderList = $sorted;
	
	// clear the slider frame
	shapesMain_removeAllTargetSlider "shpUI_sliderFrame";
	// and add new sliders from the modified list
	for ($slider in $sliderList)
	{
		string $items[] = stringToStringArray($slider, ",");
		float $value = $items[2];
		shapesDriver_addSequenceSlider {$items[1]} {$value} 0;
	}
}


global proc string[] shapesDriver_getSequenceSlider()
{
	//
	// returns a comma separated list of all sliders for the driver sequence consisting of:
	// - layout
	// - target
	// - value
	//
	string $sliderList[];
	string $items[] = `frameLayout -q -ca shpUI_sliderFrame`;
	for ($i in $items)
	{
		string $ctrls[] = `rowLayout -q -ca $i`;
		string $layout = $i;
		string $target = `text -q -l $ctrls[0]`;
		string $value = `floatSliderGrp -q -v $ctrls[2]`;
		$sliderList[size($sliderList)] = $layout + "," + $target + "," + $value;
	}
	return $sliderList;
}


global proc shapesDriver_updateSequenceDriverValue( string $slider, string $valueField )
{
	//
	// update the real driver value in the slider label
	//
	global float $gShapes_sequenceMax;
	
	float $value = `floatSliderGrp -q -v $slider`;
	floatField -e -v (shapesCommon_roundFloat(($gShapes_sequenceMax * $value), 3)) $valueField;
}


global proc shapesDriver_updateSequenceSlider( string $slider, string $valueField )
{
	//
	// update the real driver value in the slider label
	//
	global float $gShapes_sequenceMax;
	
	float $value = `floatField -q -v $valueField`;
	floatSliderGrp -e -v (shapesCommon_roundFloat(($value / $gShapes_sequenceMax), 3)) $slider;
}


global proc shapesDriver_updateSequence()
{
	//
	// delete the previous shape sequence and create a new one
	//
	global string $gShapes_currentSequenceTarget;
	global string $gShapes_selectedTarget;
	
	shapesDriver_orderSequence;
	
	// create a new sequence based on the current slider list
	string $sliderList[] = shapesDriver_getSequenceSlider();
	
	// delete the old sequence
	string $plug = shapesDriver_removeSequence($gShapes_currentSequenceTarget);
	
	// only continue if there is more than the end target in the list
	if (size($sliderList) < 2)
	{
		shapesDriver_cancelEditSequence;
		return;
	}
	
	float $values[];
	string $targets[];
	for ($slider in $sliderList)
	{
		string $items[] = stringToStringArray($slider, ",");
		$values[size($values)] = $items[2];
		$targets[size($targets)] = $items[1];
	}
	
	// check if all values are different
	string $allValues[];
	for ($v in $values)
		$allValues[size($allValues)] = $v;
	$allValues = stringArrayRemoveDuplicates($allValues);
	if (size($allValues) != size($values))
		br_displayMessage -error "All sequence values must be different";
	
	int $type = `optionMenu -q -sl shpUI_sequenceCurveOption`;
	shapesDriver_performCreateSequence $plug $values $targets $type 1 0 {} 0;
	
	// update the target list
	$gShapes_selectedTarget = $gShapes_currentSequenceTarget;
	shapesList_refreshTargetItem $targets;
	
	shapesDriver_cancelEditSequence;
}


global proc string shapesDriver_performCreateSequence( string $driverPlug, float $values[], string $targets[], int $type, int $execute, int $readSdk, string $curves[], int $mirror )
{
	//
	// creates a sdk sequence setup driven by the given node
	// and driving the given list of targets
	// returns the creation string for exporting the setup
	//
	global string $gShapes_bsNode;
	global string $gShapes_exportMirrorSetupSequenceData;
	global string $gShapes_sideIdentifier;
	
	string $driverPlugItems[] = stringToStringArray($driverPlug, ".");
	string $driver = $driverPlugItems[0];
	
	string $driverName = $driver;
	string $driverPlugName = $driverPlug;
	
	// make sure that the driver name matches the name of the sequence target
	// if the names are not matching this can create errors when rebuilding the setup;
	// only perform the renaming when creating the sequence and not during export
	// because during export all sequence information has been already connected
	// and changing the driver name would create errors
	if ($execute && $driver != ($gShapes_bsNode + "_" + $targets[size($targets) - 1] + "_WD"))
	{
		$driverPlugItems[0] = shapesDriver_renameWeightDriver($targets[size($targets) - 1], "");
		$driverPlug = stringArrayToString($driverPlugItems, ".");
		$driver = $driverPlugItems[0];
		if (`nodeType $driver` == "transform")
			$driver = shapesCommon_getShapeNode($driver);
		
		$driverName = $driver;
		$driverPlugName = $driverPlug;
	}
	
	if (!$execute && $mirror)
	{
		$driverName = shapesMirror_swapSideLabel($driverName);
		$driverPlugItems[0] = $driverName;
		$driverPlugName = stringArrayToString($driverPlugItems, ".");
		$gShapes_sideIdentifier = "";
	}
	
	string $netNode = "SHAPES_" + $targets[size($targets) - 1] + "_sequence_net";
	string $attrName = "SHAPES_sdks";
	
	if ($mirror)
	{
		// call the label swapping just to get the identifier
		shapesMirror_swapSideLabel($gShapes_bsNode);
		if (startsWith($gShapes_sideIdentifier, "_"))
			$netNode = $netNode + $gShapes_sideIdentifier;
		else if (endsWith($gShapes_sideIdentifier, "_"))
			$netNode = $gShapes_sideIdentifier + $netNode;
		$gShapes_sideIdentifier = "";
	}
	
	// store the number of values for the loop
	// since it has to be modified to start with a 0 value
	int $count = size($values);
	
	// insert the 0 value at the beginning of the value list
	shapesArray_floatArrayInsertAtIndex(0, $values, 0);
	
	// create the sequence node and add the attributes
	string $cmd;
	$cmd += "createNode network -n " + $netNode + ";\n";
	$cmd += "addAttr -ln \"driverValue\" -at double " + $netNode + ";\n";
	$cmd += "addAttr -at message -ln " + $attrName + " " + $netNode + ";\n";
	$cmd += "addAttr -dt \"string\" -ln \"SHAPES_sequenceTarget\" " + $netNode + ";\n";
	$cmd += "setAttr \"" + $netNode + ".SHAPES_sequenceTarget\" -l 1 -type \"string\" sequenceOut" + ($count - 1) + ";\n";
	
	string $tangents = "-itt auto -ott auto ";
	if ($type == 2)
		$tangents = "-itt linear -ott linear ";
	
	string $angleWeightString;
	
	for ($i = 0; $i < $count; $i ++)
	{
		// add the attribute for each target to be driven
		string $outAttr = "sequenceOut" + $i;
		$cmd += "addAttr -ln " + $outAttr + " -at double " + $netNode + ";\n";
		
		// if a new sequence is created or an update should be performed
		// create new sdk curves
		// when the call comes from exporting the setup the existing
		// sdk curves can be read instead
		if (!$readSdk)
		{
			// set the alternating value which defines the on/off behaviour of the sdk
			float $value = 0;
		
			// create three keyframes for each target
			for ($k = 0; $k < 3; $k ++)
			{
				int $set = 1;
				// for the last target skip the generation of the last keyframe
				// because it only needs to be turned on
				if ($i == $count - 1 && $k == 2)
					$set = 0;
			
				// create the sdk
				if ($set)
				{
					float $driverValue = $values[$i + $k];
					$cmd += "setDrivenKeyframe -dv " + $driverValue + " -v " + $value + " " + $tangents + "-cd " + ($netNode + ".driverValue") + " " + ($netNode + "." + $outAttr) + ";\n";
				}
				// toggle the value for the next curve
				$value = 1 - $value;
			
				if ($type == 3)
				{
					if ($k == 1)
					{
						$angleWeightString += "keyTangent -e -wt 1 " + $netNode + "_" + $outAttr + ";\n";
						$angleWeightString += "keyTangent -e -in " + $k + " -ia 8 -iw 1.0 -oa 8 -ow 1.5 " + $netNode + "_" + $outAttr + ";\n";
					}
					else if ($k == 2 && $i == $count - 2)
					{
						$angleWeightString += "keyTangent -e -wt 1 " + $netNode + "_" + $outAttr + ";\n";
						$angleWeightString += "keyTangent -e -in " + $k + " -ia -12 -iw 0.8 -oa -12 -ow 0.8 " + $netNode + "_" + $outAttr + ";\n";
					}
				}
			}
		}
		else
		{
			// use $gShapes_exportMirrorSetupSequenceData to store the network node name
			// during the read procedure;
			// it's used during the mirrored export of the setup when the mirror flag
			// for the sdkRead has to be off for the sequence but the sdk driver name needs to
			// have the side identifier order to make the export work correctly
			$gShapes_exportMirrorSetupSequenceData = $netNode;
			$cmd += shapesUtil_readSdk($curves[$i], $netNode + "." + $outAttr, 0, 0);
			$gShapes_exportMirrorSetupSequenceData = "";
		}
	}
	// get the message attribute from the driver plug
	string $attrList[] = `listAttr -m -ud $driver`;
	
	// connect the driver with the sequencer
	$cmd += "connectAttr -f " + $driverPlugName + " " + $netNode + ".driverValue;\n";
	// connect the message attribute
	if (size($attrList))
		$cmd += "connectAttr -f " + $driverName + "." + $attrList[0] + " " + $netNode + "." + $attrName + ";\n";
	
	// connect the sequencer with the targets
	for ($i = 0; $i < $count; $i ++)
	{
		string $queryPlug = shapesMain_getQueryPlug($targets[$i]);
		$cmd += "connectAttr -f " + $netNode + ".sequenceOut" + $i + " " + $queryPlug + ";\n";
	}
	
	$cmd += $angleWeightString;
	
	if ($execute)
		eval $cmd;
	
	return $cmd;
}


global proc string shapesDriver_removeSequence( string $target )
{
	//
	// deletes all previous sequence nodes
	// and connects the source driver directly to the blend shape target
	// returns the plug from the source driver
	//
	string $queryPlug = shapesMain_getQueryPlug($target);
	
	// if there is no current sequence only return the driver plug
	string $sequencer = shapesDriver_getShapeSequencer($target, {});
	if ($sequencer == "")
	{
		string $conn[] = `listConnections -s 1 -d 0 -p 1 $queryPlug`;
		return $conn[0];
	}
	
	// get the connection plug from the source driver to the sequencer node
	string $conn[] = `listConnections -s 1 -d 0 -p 1 ($sequencer + ".driverValue")`;
	
	// connect the source driver to the blend shape target
	connectAttr -f $conn[0] $queryPlug;
	
	// delete the sdk curves
	delete (shapesDriver_getShapeSequenceItems($target, "curves"));
	
	// try to remove the network node
	// but it should have been deleted by deleting the sdk curves
	catch(`eval("delete " + $sequencer)`);
	
	shapesList_refreshTargetItem {$target};
	
	return $conn[0];
}


global proc shapesDriver_cancelEditSequence()
{
	//
	// exits the sequence edit mode without making modifications
	//
	global int $gShapes_sequenceProcess;
	global string $gShapes_currentSequenceTarget;
	
	// refresh the target list
	shapesList_listBlendShapeTargets 0;
	// clear the slider frame
	shapesMain_removeAllTargetSlider "shpUI_sliderFrame";
	
	shapesUI_showEditComboUI 0;
	shapesCombo_editComboToggleUI 1;
	frameLayout -e -l "Channels" shpUI_sliderFrame;
	$gShapes_sequenceProcess = 0;
	$gShapes_currentSequenceTarget = "";
}


global proc string shapesDriver_getShapeSequencer( string $target, string $nodeList[] )
{
	//
	// returns the shape sequencer node
	//
	string $queryPlug = shapesMain_getQueryPlug($target);
	
	// get the connected sdk driver node
	// have to use the shape flag because querying the weight driver node
	// without it returns the transform node instead of the shape node
	// but only the shape node has the important message attribute
	string $conn[] = `listConnections -s 1 -d 0 -sh 1 $queryPlug`;
	
	// if a non-sequence shape is queried return None
	// this is in conjunction to prevent the creation of a combo with a sequence
	// and to check for a sequence during the export
	if (!size($conn))
		return "";
	
	// get the sequence master node
	// getComboMasterNode is utilized because it checks the connection
	// between nodes via the message attribute
	// the option needs to be False in order to make it work
	$nodeList = shapesCombo_getComboMasterNode($conn[0], 0);
	if (!size($nodeList))
		return "";
	
	// get the message attribute on the master node to find the possible network node
	string $attrList[] = `listAttr -m -ud $nodeList[0]`;
	if (!size($attrList))
		return "";
	
	// remove the [] from the multi attribute (in case of the driven node)
	string $temp[] = stringToStringArray($attrList[0], "[");
	string $msgAttr = $temp[0];
	if (`gmatch $msgAttr "*_combo*"` || `gmatch $msgAttr "SHAPESData"`)
		return "";
	
	string $networkNode[] = `listConnections -s 0 -d 1 -type "network" ($nodeList[0] + "." + $msgAttr)`;
	if (!size($networkNode))
		return "";
	
	return $networkNode[0];
}


global proc string shapesDriver_getShapeSequenceMaster( string $networkNode )
{
	//
	// returns the shape sequencer master node
	//
	// get the message attribute on the network node to find the master node
	string $attrList[] = `listAttr -m -ud $networkNode`;
	// remove the [] from the multi attribute (in case of the driven node)
	string $attr[] = stringToStringArray($attrList[0], "[");
	string $masterNode[] = `listConnections -s 1 -d 0 ($networkNode + "." + $attr[0])`;
	return $masterNode[0];
}


global proc string[] shapesDriver_getShapeSequenceItems( string $target, string $type )
{
	//
	// returns sequence curves, targets or values
	//
	string $sequencer = shapesDriver_getShapeSequencer($target, {});
	
	if ($sequencer == "")
		return {};
	
	// get all sequence attributes on the network node
	string $attrList[] = `listAttr -ud $sequencer`;
	// remove the input attribute
	$attrList = stringArrayRemove({"driverValue"}, $attrList);
	
	string $targets[];
	string $curves[];
	string $values[];
	string $tangents[] = {"1"};
	
	// collect the sequence data
	for ($a in $attrList)
	{
		if (!`gmatch $a "SHAPES_*"`)
		{
			// get the driven blend shape targets
			string $conn[] = `listConnections -s 0 -d 1 -p 1 ($sequencer + "." + $a)`;
			$targets[size($targets)] = shapesMain_getFilteredTargetFromPlug($conn[0]);
			
			// get the curve values
			$conn = `listConnections -s 1 -d 0 ($sequencer + "." + $a)`;
			$curves[size($curves)] = $conn[0];
			string $sdkString = shapesUtil_readSdk($conn[0], "", 0, 0);
			string $temp[] = stringToStringArray($sdkString, "\n");
			$temp = stringToStringArray($temp[2], "-");
			$temp = stringToStringArray($temp[1], " ");
			string $val = $temp[1];
			
			// error just in case the sdkString has a wrong formatting
			// and the value cannot be converted to float
			if (catchQuiet(`eval("float $shapesFloatTest = " + $val)`))
			{
				br_displayMessage -warning ("Unable to read the sequence data for node " + $conn[0]);
				$val = "0.5";
			}
			
			$values[size($values)] = $val;
			
			// check for non-auto tangents
			if ($tangents[0] == "1")
			{
				if (`gmatch $sdkString "*keyTangent*"`)
					$tangents[0] = "3";
				else if (`gmatch $sdkString "*itt linear*"`)
					$tangents[0] = "2";
			}
		}
	}
	
	if ($type == "targets")
		return $targets;
	else if ($type == "curves")
		return $curves;
	else if ($type == "values")
		return $values;
	else if ($type == "tangents")
		return $tangents;
	
	return {};
}


global proc string shapesDriver_getSequenceEndShape( string $networkNode )
{
	//
	// returns the shape which is placed at the end of the sequence
	//
	string $plug = `getAttr ($networkNode + ".SHAPES_sequenceTarget")`;
	string $conn[] = `listConnections -s 0 -d 1 -p 1 ($networkNode + "." + $plug)`;
	return shapesMain_getFilteredTargetFromPlug($conn[0]);
}


global proc float shapesDriver_getSequenceEndValue( string $node )
{
	//
	// return the real maximum value from the shape driver
	//
	if (`nodeType $node` == "weightDriver")
		return `getAttr ($node + ".angle")`;
	else
	{
		float $values[] = shapesDriver_getSdkValues($node);
		return $values[2];
	}
}


global proc SHAPES_driver(){}
