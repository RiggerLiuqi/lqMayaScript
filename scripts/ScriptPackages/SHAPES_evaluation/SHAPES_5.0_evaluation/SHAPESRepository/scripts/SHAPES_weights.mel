// --------------------------------------------------------------------------------------------------
//
// SHAPES
//
// blend shape editing tool for Maya
//
// required plugins:
//   SHAPESTools
//
// Ingo Clemens
// www.braverabbit.com
//
// copyright brave rabbit, Ingo Clemens 2014-2018
//
// --------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------
//
// THE SOFTWARE PRODUCT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
// IMPLIED, INCLUDING, BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NON-INFRINGEMENT OF THIRD-PARTY RIGHTS. THE ENTIRE RISK AS TO THE QUALITY AND
// PERFORMANCE OF THE SOFTWARE PRODUCT IS WITH YOU.
// NEITHER BRAVE RABBIT NOR ITS SUPPLIERS WARRANT THAT THE FUNCTIONS CONTAINED IN THE SOFTWARE
// PRODUCT WILL MEET YOUR REQUIREMENTS OR THAT THE OPERATION OF THE SOFTWARE PRODUCT WILL BE
// UNINTERRUPTED OR ERROR-FREE. BRAVE RABBIT IS NOT OBLIGATED TO PROVIDE ANY UPDATES TO THE
// SOFTWARE.
// IN NO EVENT SHALL THE AUTHOR OF THIS SOFTWARE PRODUCT BE LIABLE FOR ANY SPECIAL, CONSEQUENTIAL,
// INCIDENTAL, DIRECT OR INDIRECT DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
// LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, FOR PERSONAL INJURY, LOSS OF BUSINESS
// INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THIS
// PRODUCT, EVEN IF THE AUTHOR OF THIS SOFTWARE PRODUCT IS AWARE OF THE POSSIBILITY OF SUCH
// DAMAGES AND KNOWN DEFECTS, ANY CLAIM BY A THIRD PARTY AND EVEN IF THE REMEDY FAILS OF ITS
// ESSENTIAL PURPOSE.
//
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
// weight maps
// --------------------------------------------------------------------------------------------------

global proc shapesWeights_paintShapeWeights()
{
	global int $gShapes_index;
	global int $gShapes_paintWeightsProcess;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_selectedTarget;
	global string $gShapes_skinMesh;
	
	//
	// start to paint weights for the current shape
	//
	if ($gShapes_skinMesh == "")
		return;
	
	if ($gShapes_selectedTarget == "")
		return;
	
	if (shapesData_isDrivenSet(shapesData_getListNameByIndex($gShapes_index)))
		return;
	
	select -r $gShapes_skinMesh;
	
	// toggle the ui elements
	shapesUI_paintWeightsToggleUI 0;
	
	$gShapes_paintWeightsProcess = 1;
	
	shapesWeights_activatePaintBlendShapeWeightsTool $gShapes_bsNode $gShapes_selectedTarget $gShapes_targetIndex 0;
}


global proc shapesWeights_activatePaintBlendShapeWeightsTool( string $node, string $target, int $index, int $base )
{
	//
	// activate the paint blend shape weights tool
	//
	string $attr = "paintTargetWeights";
	if ($base)
		$attr = "baseWeights";
	
	// hide the tool settings so that the target selection doesn't get overridden
	if (`optionVar -q SHAPESHidePaintWeightsToolSettings`)
		setToolSettingsVisible false;
	
	// the following command must be used in order to be able to paint
	// on the right blend shape node if there is more than one;
	// simply using the paint blend shapes tool still has a bug, where only one blend shape node
	// will be respected and listed in the tool options window
	artSetToolAndSelectAttr("artAttrCtx", ("blendShape." + $node + "." + $attr));
	
	// set to replace mode when chosen from the preferences
	if (`optionVar -q SHAPESUseWeightsPaintReplaceMode`)
		artAttrCtx -e -selectedattroper "absolute" `currentCtx`;
	
	if ($base)
		return;
	
	// make sure the target is also selected in the tool settings
	source artAttrBlendShapeCallback;
	catchQuiet(`artBlendShapeSelectTarget artAttrCtx $target`);
	// sets the paintable index of the blend shape node
	shapesWeights_setBlendShapePaintTargetIndex $node $index;
}


global proc shapesWeights_setBlendShapePaintTargetIndex( string $node, int $index )
{
	//
	// set the paint target index for the blend shape node
	//
	string $attr = ".inputTarget[0]";
	if (`shapesCommon_getMayaVersion` < 2013)
		$attr = "";
	setAttr ($node + $attr + ".pti") $index;
}


global proc shapesWeights_exitPaintShapeWeights()
{
	//
	// finish painting weights for the current shape
	//
	global int $gShapes_index;
	global int $gShapes_paintWeightsProcess;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	
	// toggle the ui elements
	shapesUI_paintWeightsToggleUI 1;
	
	$gShapes_paintWeightsProcess = 0;
	
	// indicate the weights on the target
	shapesList_refreshTargetList;
	
	setToolTo selectSuperContext;
	
	// Maya 2016 has a viewport 2.0 refresh bug which still shows the weights
	// after switching to another tool; reselecting the mesh forces a redraw
	if (`shapesCommon_getMayaVersion` >= 2016)
	{
		select -cl;
		select -r $gShapes_skinMesh;
	}
}


global proc shapesWeights_setWeightButtonsState( int $state )
{
	//
	// enable/disable the weight buttons when entering/leaving paint mode
	//
	string $items[] = `rowLayout -q -ca shpUI_shapeWeightsLayout`;
	stringArrayRemoveAtIndex(0, $items);
	for ($i in $items)
	{
		if (`gmatch $i "*iconTextButton*"`)
			iconTextButton -e -en $state $i;
	}
}


global proc shapesWeights_smoothShapeWeights()
{
	//
	// smoothes the entire weight map
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_selectedTarget;
	
	if (`currentCtx` != "artAttrBlendShapeContext")
		shapesWeights_activatePaintBlendShapeWeightsTool $gShapes_bsNode $gShapes_selectedTarget $gShapes_targetIndex 0;
	
	artAttrCtx -e -sao "smooth" `currentCtx`;
	artAttrCtx -e -clear `currentCtx`;
	artAttrCtx -e -sao "absolute" `currentCtx`;
}


global proc shapesWeights_shapeWeightsFlush( float $value, int $regionId )
{
	//
	// flush all weights with the given value
	//
	global int $gShapes_regionProcess;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_regionBS;
	global string $gShapes_regionTarget;
	global string $gShapes_skinMesh;
	
	if ($regionId != -1 && shapesRegion_regionIsLocked($regionId))
		return;
	
	string $bsNode = $gShapes_bsNode;
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	int $index = $gShapes_targetIndex;
	
	if ($gShapes_regionProcess)
	{
		$bsNode = $gShapes_regionBS;
		$intermediate = shapesMain_getOriginalMesh($gShapes_regionTarget, 0);
		$index = -1;
	}
	
	string $context = `currentCtx`;
	setToolTo selectSuperContext;
	br_blendShapeEditWeights -flush $value -n $bsNode -om $intermediate -i $index;
	// delete the custom intermediate if the blend shape node is not the first
	shapesMain_deleteIntermediates "";
	setToolTo $context;
}


global proc shapesWeights_copyShapeWeights()
{
	//
	// copy the weights of the current shape
	//
	global int $gShapes_targetIndex;
	global int $gShapes_weightsDataIndices[];
	global float $gShapes_weightsDataValues[];
	global string $gShapes_bsNode;
	
	int $indices[] = `br_blendShapeEditWeights -getIndices -n $gShapes_bsNode -i $gShapes_targetIndex`;
	float $weights[] = `br_blendShapeEditWeights -getWeights -n $gShapes_bsNode -i $gShapes_targetIndex`;
	if (!size($indices))
	{
		br_displayMessage -warning "No weights to copy";
		return;
	}
	
	$gShapes_weightsDataIndices = $indices;
	$gShapes_weightsDataValues = $weights;
}


global proc shapesWeights_setShapeWeights( int $indices[], float $values[] )
{
	//
	// sets the given weights for the current target
	//
	global string $gShapes_bsNode;
	
	int $nIds[] = shapesData_getShapeIds(1, {});
	int $ids[] = shapesData_getShapeIds(0, {});
	
	for ($n = 0; $n < size($nIds); $n ++)
	{
		// check if one of the selected targets is a helper attribute
		// might be possible through multi selection
		if (!shapesData_isHelper(shapesData_getListNameByIndex($ids[$n])))
			br_blendShapeEditWeights -set -n $gShapes_bsNode -i $nIds[$n] -ids $indices -w $values;
	}
}


global proc shapesWeights_removeShapeWeights( int $paste, string $shapes[] )
{
	//
	// deletes all weights from the current shape
	// and optionally paste the stored weights to the current shape
	//
	global int $gShapes_targetIndex;
	global int $gShapes_weightsDataIndices[];
	global float $gShapes_weightsDataValues[];
	global string $gShapes_bsNode;
	
	int $nIds[] = shapesData_getShapeIds(1, $shapes);
	int $ids[] = shapesData_getShapeIds(0, $shapes);
	
	for ($n = 0; $n < size($nIds); $n ++)
	{
		// check if one of the selected targets is a helper attribute
		// might be possible through multi selection
		if (!shapesData_isHelper(shapesData_getListNameByIndex($ids[$n])))
			br_blendShapeEditWeights -delete -n $gShapes_bsNode -i $nIds[$n];
	}
	
	if ($paste)
		shapesWeights_setShapeWeights $gShapes_weightsDataIndices $gShapes_weightsDataValues;
	
	shapesList_refreshTargetList;
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_paintShapeWeights;
}


global proc string shapesWeights_getFileExtension( string $default )
{
	//
	// returns the file extension based on the preference setting
	//
	if (!`optionVar -q SHAPESFileType`)
		return $default;
	else
		return "json";
}

global proc shapesWeights_exportShapeWeights( string $mapName, string $exportPath, int $freeze, int $overwrite, int $base )
{
	//
	// export the weights of the current shape
	// the mapName is given when exporting the entire setup
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	
	string $shape[];
	
	string $upper1 = "Weight";
	string $upper2 = "Weights";
	string $lower2 = "weights";
	
	if ($freeze)
	{
		string $sel[] = `ls -sl -tr`;
		if (!size($sel))
			return;
	
		$shape = `listRelatives -s -ni $sel[0]`;
		if (!size($shape))
			br_displayMessage -error ($sel[0] + " has no shape node");
		if (`nodeType $shape[0]` != "mesh")
			br_displayMessage -error ($shape[0] + " is not a mesh object");
		
		$upper1 = "Freeze";
		$upper2 = "Frozen";
		$lower2 = "frozen";
	}
	
	// first check is there is a given path;
	// in case of exporting the setup with a custom path
	if ($exportPath == "")
		$exportPath = shapesUtil_getExportPath("/weights/" + $gShapes_bsNode, 1);
	if ($exportPath == "")
		return;
	
	if ($mapName == "")
	{
		string $selMap[] = `textScrollList -q -si shpUI_shapeWeightsList`;
		string $prompt = `promptDialog 	-t ("Export " + $upper2)
										-m ("Set " + $upper1 + " Map Name")
										-tx $selMap
										-b "OK"
										-b "Cancel"
										-db "OK"
										-cb "Cancel"
										-ds "Cancel"`;
		if ($prompt == "Cancel")
			return;
	
		$mapName = `promptDialog -q -tx`;
	}
	
	string $fileName = $exportPath + "/" + $mapName + "." + shapesWeights_getFileExtension("bsw");
	
	if (!$overwrite)
	{
		if (`file -q -ex $fileName`)
		{
			string $msg = $upper1 + " map \"" + $mapName + "\" already exists.\n\nDo you want to replace it?";
			if (!shapesCommon_confirmWindow($msg, "OK"))
				return;
		}
	}
	
	int $result;
	if (!$freeze)
	{
		int $index = $gShapes_targetIndex;
		if ($base)
			$index = -1;
		$result = `br_blendShapeEditWeights -ex -fn $fileName -n $gShapes_bsNode -i $index`;
	}
	else
		$result = `br_blendShapeEditWeights -ex -fn $fileName -fp -om $shape[0]`;
	
	if ($mapName != "" && $result)
	{
		br_displayMessage -info ("Exported " + $lower2 + " to \"" + $fileName + "\".");
		
		shapesUI_toggleWeightsContextMenu 0;
		shapesUtil_buildImportMenu "shpUI_shapeWeightsList";
	}
}


global proc int shapesWeights_importShapeWeights( int $freeze, int $backup )
{
	//
	// import the weights to the current shape
	//
	global int $gShapes_index;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	
	int $return = 0;
	
	string $exportPath = shapesUtil_getExportPath("/weights/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return $return;
	
	string $mapName[] = `textScrollList -q -si shpUI_shapeWeightsList`;
	if (!size($mapName))
		return $return;
	string $fileName = $exportPath + "/" + $mapName[0] + "." + shapesWeights_getFileExtension("bsw");
	if ($backup)
	{
		if (shapesWeights_backupWeightMapExists("weights"))
			$fileName += "~";
		else
			return $return;
	}
	
	if ($freeze)
	{
		$return = shapesWeights_setPaintFreezeWeights($fileName);
		return 1;
	}
	
	// read the weights from the file and apply them
	$return = `br_blendShapeEditWeights -im -fn $fileName -n $gShapes_bsNode -i $gShapes_targetIndex`;
	
	if ($return)
		br_displayMessage -info ("Imported weight map \"" + $fileName + "\".");
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_setBlendShapePaintTargetIndex $gShapes_bsNode $gShapes_targetIndex;
	
	shapesList_refreshTargetList;
	
	return $return;
}


global proc shapesWeights_invertShapeWeights()
{
	//
	// inverts the weight map of the current shape
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	
	if ($gShapes_skinMesh == "")
		return;
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	
	int $nIds[] = shapesData_getShapeIds(1, {});
	int $ids[] = shapesData_getShapeIds(0, {});
	
	for ($n = 0; $n < size($nIds); $n ++)
		br_blendShapeEditWeights -invert -n $gShapes_bsNode -i $nIds[$n] -om $intermediate;
	
	// delete the custom intermediate if the blend shape node is not the first
	shapesMain_deleteIntermediates "";
	
	shapesList_refreshTargetList;
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_paintShapeWeights;
}


global proc shapesWeights_mirrorShapeWeights()
{
	//
	// mirrors the weight map of the current shape
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	
	// change the tool to avoid any warnings
	// duplicating the mesh with the paint tool active results in
	// // Warning: Invalid UV map on mesh.
	string $lastTool = `currentCtx`;
	setToolTo selectSuperContext;
	
	string $axis = shapesMirror_getAxisString();
	int $dir = `optionVar -q SHAPESMirrorDirection`;
	
	float $tolerance = `optionVar -q SHAPESMirrorToleranceValue`;
	
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	
	// check if the mirror mode is order based and the shape has order mapping stored;
	// if the mapping data doesn't exist but the order based mirroring is enabled
	// the mirror mode needs to be set back to position based mirroring
	if (`optionVar -q SHAPESSymmetry` && !shapesMirror_hasOrderMapping(shapesMain_getShapeNode()))
		shapesUI_setSymmetryStatus 0;
	
	string $orderBasedFlag = "";
	if (`optionVar -q SHAPESSymmetry`)
		$orderBasedFlag = "-ob \"" + shapesMain_getShapeNode() + "\" ";
	
	int $nIds[] = shapesData_getShapeIds(1, {});
	int $ids[] = shapesData_getShapeIds(0, {});
	
	for ($n = 0; $n < size($nIds); $n ++)
	{
		string $cmd = "br_blendShapeEditWeights -mirror ";
		$cmd += $orderBasedFlag;
		$cmd += "-node \"" + $gShapes_bsNode + "\" ";
		$cmd += "-index " + $nIds[$n] + " ";
		$cmd += "-originalMesh \"" + $intermediate + "\" ";
		$cmd += "-axis \"" + $axis + "\" ";
		$cmd += "-direction " + $dir + " ";
		$cmd += "-tolerance " + $tolerance + " ";
		
		int $result = `eval $cmd`;
	}
	
	// delete the custom intermediate if the blend shape node is not the first
	shapesMain_deleteIntermediates "";
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_setBlendShapePaintTargetIndex $gShapes_bsNode $gShapes_targetIndex;
	
	shapesList_refreshTargetList;
	
	if (`gmatch $lastTool "*artAttrBlendShapeContext*"`)
		shapesWeights_paintShapeWeights;
}


global proc shapesWeights_trimShapeWeights( int $positive )
{
	//
	// trims the weights to appear only on the positive axis
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	
	int $nIds[] = shapesData_getShapeIds(1, {});
	int $ids[] = shapesData_getShapeIds(0, {});
	
	string $axis = shapesMirror_getAxisString();
	float $tolerance = `optionVar -q SHAPESMirrorToleranceValue`;
	
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	
	for ($n = 0; $n < size($nIds); $n ++)
		br_blendShapeEditWeights -trim -n $gShapes_bsNode -i $nIds[$n] -om $intermediate -ax $axis -dir $positive -tol $tolerance;
	
	// delete the custom intermediate if the blend shape node is not the first
	shapesMain_deleteIntermediates "";
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_paintShapeWeights;
}


global proc string[] shapesWeights_getListBasedInfo( string $type )
{
	//
	// return a list of infos about the given list type
	// unifying renaming and deleting of weight and region maps
	//
	// info order:
	// [0] list, [1] typePath, [2] upCase, [3] lowCase, [4] ext, [5] context
	string $info[];
	if ($type == "weights")
		$info = {"shpUI_shapeWeightsList", "weights", "Weight", "weight", ("." + shapesWeights_getFileExtension("bsw"))};
	else if ($type == "region")
		$info = {"shpUI_regionList", "regions", "Region", "region", ("." + shapesWeights_getFileExtension("bsr"))};
	return $info;
}


global proc shapesWeights_renameWeightMap( string $type )
{
	//
	// renames the weight/region map file on disk
	//
	global string $gShapes_bsNode;
	
	string $info[] = shapesWeights_getListBasedInfo($type);
	
	string $oldName[] = `textScrollList -q -si $info[0]`;
	
	string $exportPath = shapesUtil_getExportPath("/" + $info[1] + "/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return;
	
	string $prompt = `promptDialog 	-t "Rename"
									-m ("New " + $info[2] + " Map Name")
									-tx $oldName[0]
									-b "OK"
									-b "Cancel"
									-db "OK"
									-cb "Cancel"
									-ds "Cancel"`;
	if ($prompt == "Cancel")
		return;
	
	string $mapName = `promptDialog -q -tx`;
	
	string $oldFileName = $exportPath + "/" + $oldName[0] + $info[4];
	string $fileName = $exportPath + "/" + $mapName + $info[4];
	
	python("import os; os.rename('" + $oldFileName + "', '" + $fileName + "')");
	
	string $cmd;
	if ($info[1] == "regions")
		$cmd = "shapesUI_toggleRegionListMenuItems 0";
	else
		$cmd = "shapesUI_toggleWeightsContextMenu 0";
	eval $cmd;
	shapesUtil_buildImportMenu $info[0];
	
	// in case of region file renaming also check
	// if the current region map name needs to be updated as well
	if ($info[1] == "regions")
	{
		string $fieldText = `textField -q -tx shpUI_currentRegionNameField`;
		if ($fieldText == $oldName[0])
		{
			textField -e -tx $mapName shpUI_currentRegionNameField;
			
			string $node = "SHAPESRegionData";
			lockNode -l 0 $node;
			setAttr ($node + ".regionMap") -type "string" $mapName;
			lockNode -l 1 $node;
		}
	}
}


global proc shapesWeights_deleteWeightMap( string $type )
{
	//
	// deletes the weight/region map file on disk
	//
	global string $gShapes_bsNode;
	global string $gShapes_undoInfo;
	
	string $info[] = shapesWeights_getListBasedInfo($type);
	
	string $mapName[] = `textScrollList -q -si $info[0]`;
	
	string $msg = "Delete " + $info[3] + " map file?\n\n" + $gShapes_undoInfo;
	if (!shapesCommon_confirmWindow($msg, "Delete"))
		return;
	
	string $exportPath = shapesUtil_getExportPath("/" + $info[1] + "/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return;
	
	string $fileName = $exportPath + "/" + $mapName[0] + $info[4];
	
	python("import os; os.remove('" + $fileName + "')");
	
	br_displayMessage -info ("Deleted " + $info[3] + " map " + $fileName + ".");
	
	string $cmd;
	if ($info[1] == "regions")
		$cmd = "shapesUI_toggleRegionListMenuItems 0";
	else
		$cmd = "shapesUI_toggleWeightsContextMenu 0";
	eval $cmd;
	shapesUtil_buildImportMenu $info[0];
	
	if ($info[3] == "region")
		shapesRegion_clearRegionData $mapName[0];
}


global proc shapesWeights_duplicateWeightMap( string $type, int $asBackup )
{
	//
	// creates a copy or backup of the weight/region map file on disk
	//
	global string $gShapes_bsNode;
	
	string $info[] = shapesWeights_getListBasedInfo($type);
	
	string $currentName[] = `textScrollList -q -si $info[0]`;
	
	string $exportPath = shapesUtil_getExportPath("/" + $info[1] + "/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return;
	
	string $currentFileName = $exportPath + "/" + $currentName[0] + $info[4];
	string $fileName;
	if (!$asBackup)
		$fileName = $exportPath + "/" + $currentName[0] + "_copy" + $info[4];
	else
		$fileName = $currentFileName + "~";
	
	python("import shutil; shutil.copy2('" + $currentFileName + "', '" + $fileName + "')");
	
	if (!$asBackup)
	{
		br_displayMessage -info ("Copied map to " + $fileName + ".");
		shapesUtil_buildImportMenu $info[0];
	}
	else
	{
		br_displayMessage -info ("Created backup of map " + $currentFileName + ".");
	}
}


global proc int shapesWeights_backupWeightMapExists( string $type )
{
	global string $gShapes_bsNode;
	
	string $info[] = shapesWeights_getListBasedInfo($type);
	
	string $currentName[] = `textScrollList -q -si $info[0]`;
	
	string $exportPath = shapesUtil_getExportPath("/" + $info[1] + "/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return 0;
	
	string $currentFileName = $exportPath + "/" + $currentName[0] + $info[4] + "~";
	int $exists = `filetest -e $currentFileName`;
	
	if (!$exists)
		br_displayMessage -warning ("A backup map for " + $currentName[0] + " does not exist");
	
	return $exists;
}


global proc shapesWeights_freezeShapeWeights( string $shapes[] )
{
	//
	// applies the scaled vertex position from the the weight map to the
	// target shape and deletes the weight map
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	
	// the freezing needs to be performed through a command string collection
	// because if executing the command through a loop an error occurs
	// that the weight information cannot be found even though it should make no difference
	string $cmd;
	
	int $nIds[] = shapesData_getShapeIds(1, $shapes);
	int $ids[] = shapesData_getShapeIds(0, $shapes);
	for ($n = 0; $n < size($nIds); $n ++)
	{
		int $values[] = shapesData_getTargetValues($nIds[$n]);
		for ($v in $values)
			$cmd += "br_blendShapeEditWeights -freeze -n " + $gShapes_bsNode + " -i " + $nIds[$n] + " -tv " + $v + ";\n";
	}
	eval $cmd;
	
	shapesList_refreshTargetList;
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_paintShapeWeights;
}


global proc int shapesWeights_setPaintFreezeWeights( string $fileName )
{
	//
	// writes the vertex color information for the freeze brush
	// from the weight list file
	//
	string $sel[] = `ls -sl -tr`;
	if (!size($sel))
		return 0;
	
	string $shape[] = `listRelatives -s -ni $sel[0]`;
	if (!size($shape))
		br_displayMessage -error ($sel[0] + " has no shape node");
	if (`nodeType $shape[0]` != "mesh")
		br_displayMessage -error ($shape[0] + " is not a mesh object");
	
	string $currentContext = `currentCtx`;
	PaintVertexColorTool;
	
	if (!`optionVar -q SHAPESUseMayaSculptTool`)
	{
		string $artContext = `currentCtx`;
		if ($currentContext != "artAttrColorPerVertexContext")
			br_displayMessage -error "The brush freeze paint mode must be enabled to write the freeze data";
	
		// flood everything black to set all vertices
		artAttrPaintVertexCtx -e -colorRGBValue 0 0 0 $artContext;
		artAttrPaintVertexCtx -e -clear $artContext;
		artAttrPaintVertexCtx -e -colorRGBValue 0.4 0.7 1.0 -selectedattroper "absolute" $artContext;
	}
	
	int $return = `br_blendShapeEditWeights -im -fp -fn $fileName -om $shape[0]`;
	
	setToolTo $currentContext;
	
	return $return;
}


global proc shapesWeights_combineWeightMap( int $add )
{
	//
	// adds or subtracts the weights from the selected weight map file
	// to/from the the current weights
	//
	global int $gShapes_index;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	
	string $exportPath = shapesUtil_getExportPath("/weights/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return;
	
	string $mapName[] = `textScrollList -q -si shpUI_shapeWeightsList`;
	if (!size($mapName))
		return;
	string $fileName = $exportPath + "/" + $mapName[0] + "." + shapesWeights_getFileExtension("bsw");
	
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	
	string $cmd = "br_blendShapeEditWeights ";
	if ($add)
		$cmd += "-add ";
	else
		$cmd += "-sub ";
	$cmd += "-fn \"" + $fileName + "\" -n " + $gShapes_bsNode + " -i " + $gShapes_targetIndex + " -om " + $intermediate;
	
	// read the weights from the file and apply them
	int $return = `eval $cmd`;
	
	// delete the custom intermediate if the blend shape node is not the first
	shapesMain_deleteIntermediates "";
	
	if ($return)
	{
		shapesList_refreshTargetList;
		
		// sets the paintable index of the blend shape node
		if (`currentCtx` == "artAttrBlendShapeContext")
			shapesWeights_paintShapeWeights;
	}
}


// --------------------------------------------------------------------------------------------------
// ramp weights & weights server
// --------------------------------------------------------------------------------------------------


global proc shapesWeights_editWeightsController( string $shape, int $index, string $ctrl )
{
	//
	// displays the options to create, edit or delete a ramp weights node
	//
	global string $gShapes_bsNode;
	global string $gShapes_rampPlug;
	
	string $buttonList[] = {"OK", "Cancel"};
	string $msg;
	string $conn[];
	
	string $type = "";
	string $items[] = stringToStringArray($ctrl, ".");
	if (size($items))
	{
		if (`nodeType $items[0]` == "rampWeights")
			$type = "ramp";
		else if (`nodeType $items[0]` == "weightsServer")
			$type = "server";
	}
	
	if ($ctrl != "")
	{
		if ($type == "ramp")
		{
			$msg = "Process Ramp Weights";
		
			// check if a driver for the offset is already present
			$buttonList = {"Select", " Create Driver ", "Delete", "Cancel"};
			if (`gmatch $ctrl "*.*"`)
				$buttonList = {"Select", " Select Driver ", " Delete Driver ", "Delete", "Delete Node", "Cancel"};
		}
		else if ($type == "server")
		{
			if (!shapesWeights_weightsServerGetTransfer($ctrl))
			{
				$msg = "Process Weights Server";
				$buttonList = {"Select", " Edit Influences ", " Open Editor ", "Delete", "Delete Node", "Cancel"};
			}
			else
			{
				$msg = "Weights Server Influence Map";
				$buttonList = {"Delete", "Cancel"};
			}
		}
	}
	string $confirm = "";
	if ($ctrl != "")
	{
		string $cmd = "confirmDialog -t \"SHAPES\" -m \"" + $msg + "\" -b \"" + stringArrayToString($buttonList, "\" -b \"") + "\" -db \"Cancel\" -cb \"Cancel\" -ds \"Cancel\"";
		$confirm = `eval $cmd`;
	}
	else
	{
		shapesUI_buildCreateWeightsControllerUI $shape $index;
		return;
	}
	
	if ($confirm == "Cancel")
		return;
	
	if ($ctrl != "")
	{
		string $rampAttr = "";
		if ($type == "ramp")
		{
			$rampAttr = "offset";
			if (`optionMenu -q -ex shpUI_rampAttrOption`)
				$rampAttr = `optionMenu -q -v shpUI_rampAttrOption`;
		
			if (`gmatch $ctrl "*.*"`)
				$gShapes_rampPlug = $ctrl;
			else
				$gShapes_rampPlug = $ctrl + "." + $rampAttr;
		}
		
		if ($confirm == "Delete")
		{
			if (!shapesWeights_weightsServerGetTransfer($ctrl))
				shapesWeights_deleteWeightsController $items[0] $type $shape $index 1;
			else
				shapesWeights_deleteInfluenceMapSetup $ctrl;
		}
		if ($confirm == "Delete Node")
		{
			shapesWeights_deleteWeightsController $items[0] $type $shape $index 0;
		}
		else if ($confirm == "Select")
		{
			select -r $items[0];
			return;
		}
		else if ($confirm == " Create Driver ")
		{
			shapesDriver_createWeightDriver("", 0, 0);
			$ctrl += "." + $rampAttr;
		}
		else if ($confirm == " Select Driver ")
		{
			shapesDriver_collectDriverInfo;
			return;
		}
		else if ($confirm == " Delete Driver ")
		{
			shapesDriver_deleteWeightDriver "" 0;
			$gShapes_rampPlug = "";
		}
		else if ($confirm == " Edit Influences ")
		{
			shapesUI_toggleWeightsServerUpdateButton $index 1;
		}
		else if ($confirm == " Open Editor ")
		{
			weightsServerEditInfluences;
			evalDeferred("weightsServerSelectOptionByName " + $items[0]);
		}
	}
	
	// indicate the ramp on the target
	int $ids[] = shapesData_getShapeIds(0, {$shape});
	shapesList_refreshTargetList;
}


global proc shapesWeights_createWeightsController( string $shape, int $index, string $radioGrp1, string $radioGrp2, string $nodeOptionLayout )
{
	//
	// initiates the creation of a ramp weights or weights server node
	// based on the user selection
	//
	global string $gShapes_rampPlug;
	
	string $controls[] = `columnLayout -q -ca $nodeOptionLayout`;
	string $node = `optionMenu -q -v $controls[0]`;
	
	string $type = "ramp";
	if (`radioButtonGrp -q -sl $radioGrp1` == 2)
	{
		$type = "server";
		
		if (`radioButtonGrp -q -sl $radioGrp2` == 2)
		{
			deleteUI SHAPESWeightsControllerWin;
			
			// if multiple target shapes are selected
			// these have weights present re-create the influence map
			string $sel[] = `treeView -q -si shpUI_targetTree`;
			int $weights = 1;
			if (size($sel) > 1)
			{
				for ($s in $sel)
				{
					$weights = shapesData_hasWeights(shapesData_getShapeIndex($s));
					if (!$weights)
						break;
				}
				
				if ($weights)
					shapesWeights_performCreateInfluenceMap;
				else
					br_displayMessage -warning "All selected targets need to have weights to create the influence map";
				return;
			}
			
			// select the target if not already selected
			treeView -e -si $shape 1 shpUI_targetTree;
			shapesMain_buildTargetSlider;
			
			shapesUI_buildInfluenceMapUI;
			return;
		}
	}
	
	shapesWeights_performCreateWeightsController($type, $shape, $index, $node);
	$gShapes_rampPlug = "";
	
	deleteUI SHAPESWeightsControllerWin;
	
	// indicate the ramp on the target
	int $ids[] = shapesData_getShapeIds(0, {$shape});
	shapesList_refreshTargetList;
}


global proc string shapesWeights_performCreateWeightsController( string $type, string $shape, int $index, string $node )
{
	//
	// creates a ramp weights or weights server node
	//
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	
	if ($node != "New")
	{
		int $id = shapesCommon_findEmptyMultiIndex($node + ".weightList");
		connectAttr -f ($node + ".weightList[" + $id + "].weights") ($gShapes_bsNode + ".it[0].itg[" + $index + "].tw");
	}
	else
	{
		if ($type == "ramp")
			$node = brPerformCreateRampWeights($gShapes_skinMesh, $gShapes_bsNode, $index, $shape);
		else if ($type == "server")
			$node = brPerformCreateWeightsServer($gShapes_skinMesh, $gShapes_bsNode, $index, $shape);
	}
	
	return $node;
}


global proc shapesWeights_deleteWeightsController( string $node, string $type, string $shape, int $index, int $all )
{
	//
	// deletes the weights controller or removes the connection
	// if the controller is shared between targets
	//
	global string $gShapes_rampPlug;
	
	string $conn[] = `listConnections -s 0 -d 1 -c 1 -p 1 ($node + ".weightList")`;
	
	if (size($conn) > 2)
	{
		for ($i = 0; $i < size($conn); $i += 2)
		{
			if (`gmatch $conn[$i + 1] ("*inputTargetGroup\\[" + $index + "\\]*")`)
			{
				disconnectAttr $conn[$i] $conn[$i + 1];
				break;
			}
		}
		
		if ($all)
			shapesWeights_removeShapeWeights 0 {$shape};
	}
	else
	{
		select -r $node;
		if ($type == "ramp")
			brDeleteRampWeights $all;
		else if ($type == "server")
			brDeleteWeightsServer $all;
	}
	$gShapes_rampPlug = "";
}


global proc string[] shapesWeights_disconnectWeightsController( string $node, string $shape )
{
	//
	// disconnects the ramp weights or weights server from the blend shape target channel,
	// resets the weights, but keeps the ramp weights node;
	// returns the plug connections
	//
	if ($node == "")
		return {};
	
	string $return[];
	string $conn[] = `listConnections -s 0 -d 1 -p 1 -c 1 ($node + ".weightList")`;
	for ($i = 0; $i < size($conn); $i += 2)
	{
		string $items[] = stringToStringArray($conn[$i + 1], ".");
		$items = stringToStringArray($items[2], "[");
		$items = stringToStringArray($items[1], "]");
		int $index = $items[0];
		if (shapesData_getShapeIndex($shape) == $index)
		{
			disconnectAttr $conn[$i] $conn[$i + 1];
			$return[0] = $conn[$i];
			$return[1] = $conn[$i + 1];
			break;
		}
	}
	shapesWeights_removeShapeWeights 0 {$shape};
	return $return;
}


global proc int shapesWeights_weightsServerGetInfluences( string $node, string $nodeList[] )
{
	//
	// returns true if the given weights server node has influence connections
	//
	$nodeList = `listConnections -s 1 -d 0 ($node + ".influence")`;
	return size($nodeList);
}


global proc int shapesWeights_weightsServerGetTexture( string $node )
{
	//
	// returns true if the given weights server node has a texture connection
	//
	string $map[] = `listConnections -s 1 -d 0 ($node + ".texture")`;
	return size($map);
}


global proc int shapesWeights_weightsServerGetTransfer( string $node )
{
	//
	// returns true if the given weights server node has a texture connection
	//
	int $value = `getAttr ($node + ".useTransfer")`;
	return $value;
}


global proc shapesWeights_listServerInfluences( string $server )
{
	//
	// selects the influences for the weights server
	// in the weight driver list
	//
	evalDeferred("treeView -e -cs shpUI_driverTree");
	
	string $infList[];
	shapesWeights_weightsServerGetInfluences $server $infList;
	for ($inf in $infList)
	{
		if (!`treeView -q -iex $inf shpUI_driverTree`)
			shapesList_storeCustomDriver $inf 0;
	}
	
	for ($inf in $infList)
		evalDeferred("treeView -e -si " + $inf + " 1 shpUI_driverTree");
}


global proc shapesWeights_editServerInfluences( string $server )
{
	//
	// adds or removes influences for the weights server
	//
	int $clear = 0;
	string $nodeItems[] = `treeView -q -si shpUI_driverTree`;
	if (size($nodeItems))
	{
		for ($node in $nodeItems)
		{
			if (shapesList_isDriverGroup($node))
				br_displayMessage -error "No influence node selected";
		}
	}
	else
		$clear = 1;
	
	brConnectWeightsServerInfluence "" $server $nodeItems $clear;
	
	shapesUI_toggleWeightsServerUpdateButton -1 0;
	
	shapesList_refreshTargetList;
}


// --------------------------------------------------------------------------------------------------
// influence maps
// --------------------------------------------------------------------------------------------------

global proc shapesWeights_performCreateInfluenceMap()
{
	//
	// duplicate the current shape and create the setup
	//
	global string $gShapes_bsNode;
	
	int $nIds[] = shapesData_getShapeIds(1, {});
	int $ids[] = shapesData_getShapeIds(0, {});
	
	if (!size($ids))
		return;
	
	string $influences[];
	int $indices[];
	
	string $listName = shapesData_getListNameByIndex($ids[0]);
	//
	// create a new group and duplicate the shape
	//
	if (size($ids) == 1)
	{
		string $groupName = shapesUI_getInfluenceMapGroupName();
		string $group = shapesUI_addShapeHelperAttribute(1, $groupName, 5);
		
		string $strings[] = shapesUI_getInfluenceMapStrings();
		
		for ($i = 0; $i < size($strings); $i ++)
		{
			string $shape = shapesWeights_createInfluenceName($strings[$i], $listName);
			string $newName[] = shapesAction_newChannelName($gShapes_bsNode, $shape);
			if ($newName[1] != "")
				$shape = $newName[1];
			
			shapesAction_duplicateSelectedChannel $shape;
			shapesList_setNewParent($shape, $group);
			shapesList_listBlendShapeTargets 0;
			
			$influences[size($influences)] = $shape;
			$indices[size($indices)] = shapesData_getShapeIndex($shape);
		}
	}
	//
	// create a new setup and connect the selected shapes
	//
	else
	{
		for ($i = 0; $i < size($nIds); $i ++)
		{
			string $shape = shapesData_getListNameByIndex($ids[$i]);
			$influences[size($influences)] = $shape;
			$indices[size($indices)] = shapesData_getShapeIndex($shape);
		}
		
		// clear the name to tell the creation process
		// that the setup needs to be re-created
		$listName = "";
	}
	
	shapesWeights_createInfluenceMapSetup $listName $influences $indices;
	
	if (`window -ex SHAPESInfluenceMapSettingsWin`)
		deleteUI SHAPESInfluenceMapSettingsWin;
	
	shapesList_listBlendShapeTargets 0;
}


global proc shapesWeights_createInfluenceMapSetup( string $name, string $joints[], int $mapIds[] )
{
	//
	// create the joints and skin cluster
	// for the influence setup
	//
	global string $gShapes_bsNode;
	
	// when re-creating the setup there is no single shape name given
	// which can be used to name the groups;
	// instead get the parent of one shape and extract the group name
	int $rebuild = 0;
	if ($name == "")
	{
		string $parent = `treeView -q -ip $joints[0] shpUI_targetTree`;
		string $items[] = stringToStringArray($parent, "_influenceMap");
		$name = $items[0];
		$rebuild = 1;
	}
	
	string $skin = shapesAction_duplicateOrginalMesh("");
	$skin = `rename $skin ($name + "_mapSkin_geo")`;
	sets -e -fe initialShadingGroup $skin;
	setAttr ($skin + ".v") 1;
	string $grp = `createNode transform -n ($name + "_mapSkin_grp")`;
	select -cl;
	
	float $bbox[] = `xform -q -bb $skin`;
	string $axis = shapesMirror_getAxisString();
	float $min = $bbox[0];
	float $max = $bbox[3];
	float $vPos = $bbox[1] + ($bbox[4] - $bbox[1]) / 2.0;
	float $hPos = $bbox[2] + ($bbox[5] - $bbox[2]) / 2.0;
	if ($axis == "y")
	{
		$min = $bbox[1];
		$max = $bbox[4];
		$vPos = $bbox[0] + ($bbox[3] - $bbox[0]) / 2.0;
	}
	else if ($axis == "z")
	{
		$min = $bbox[2];
		$max = $bbox[5];
		$vPos = $bbox[1] + ($bbox[4] - $bbox[1]) / 2.0;
	}
	
	string $cmd = "skinCluster -tsb -n " + $name + "_skinCluster " + $skin;
	for ($i = 0; $i < size($joints); $i ++)
	{
		float $pos = $min + ($i * ($max + abs($min)) / (size($joints) - 1));
		string $joint = `joint -p $pos $vPos $hPos -n ($joints[$i] + "_mapJoint")`;
		select -cl;
		parent $joint $grp;
		$cmd += " " + $joint;
	}
	
	string $skinCluster[] = `eval $cmd`;
	
	if ($rebuild)
	{
		setAttr ($skinCluster[0] + ".normalizeWeights") 0;
		for ($i = 0; $i < size($mapIds); $i ++)
			br_blendShapeEditWeights -ex -n $gShapes_bsNode -i $mapIds[$i] -sc $skinCluster[0] -sm $skin -ii $i;
		setAttr ($skinCluster[0] + ".normalizeWeights") 1;
	}
	
	string $node = `createNode weightsServer -n ($name + "_influenceMap_WS")`;
	setAttr ($node + ".useTransfer") 1;
	connectAttr -f ($skinCluster[0] + ".outputGeometry[0]") ($node + ".inputTransfer");
	int $tid = 1;
	for ($i = 0; $i < size($joints); $i ++)
	{
		connectAttr -f ($node + ".ot[" + $i + "].tw") ($gShapes_bsNode + ".it[0].itg[" + $mapIds[$i] + "].tw");
		$tid ++;
	}
}


global proc string shapesWeights_createInfluenceName( string $itemStrings, string $shape )
{
	//
	// create the influence name for the joints
	//
	string $strings[] = stringToStringArray($itemStrings, ",");
	string $name = $strings[0];
	
	// replace the placeholder with the proper name
	string $placeholder[] = {"<shape>"};
	string $replacement[] = {$shape};
	for ($i = 0; $i < size($placeholder); $i ++)
		$name = substituteAllString($name, $placeholder[$i], $replacement[$i]);
	
	if ($strings[1] != "")
	{
		if (!startsWith($strings[1], "_"))
			$name = $strings[1] + $name;
		else
			$name = $name + $strings[1];
	}
	
	return $name;
}


global proc shapesWeights_deleteInfluenceMapSetup( string $node )
{
	//
	// deletes the weights controller and removes
	// the influence map setup
	//
	string $conn[] = `listConnections -s 0 -d 1 -c 1 -p 1 ($node + ".outputTransfer")`;
	
	// remove any output connections before deleting the node
	// to keep the weights on the blend shape node
	if (size($conn) > 2)
	{
		for ($i = 0; $i < size($conn); $i += 2)
			disconnectAttr $conn[$i] $conn[$i + 1];
	}
	
	$conn = `listConnections -s 1 -d 0 ($node + ".inputTransfer")`;
	string $infl[] = `skinCluster -q -inf $conn[0]`;
	string $group[] = `listRelatives -p $infl[0]`;
	
	string $mesh;
	string $hist[] = `listHistory $conn[0]`;
	for ($h in $hist)
	{
		if (`nodeType $h` == "mesh")
		{
			string $trans[] = `listRelatives -p $h`;
			$mesh = $trans[0];
			break;
		}
	}
	
	delete $node;
	delete $mesh;
	delete $group;
}


global proc SHAPES_weights(){}
